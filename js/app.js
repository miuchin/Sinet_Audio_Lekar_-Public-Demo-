/*
  SINET Audio Lekar — App Core
  File: js/app.js
  Version: 15.7.1.6 (Hotfix: fix class-body stray token; keep Dock Loop + Frequencies)
  Author: miuchins | Co-author: SINET AI
*/

// Cache-bust audio engine updates (NO-SW mode relies on browser cache)
import { SinetAudioEngine } from './audio/audio-engine.js?v=15.7.1.6';
import { renderProtocolToWavBlobURL, estimateWavBytes } from './audio/ios-rendered-track.js?v=15.7.1.6';
import { normalizeCatalogPayload } from './catalog/stl-adapter.js?v=15.7.1.6';

const SINET_APP_VERSION = "15.7.1.6";



// v15.7.1.6 — default segment length for long sessions (esp. iOS PRO rendered WAV)
const DEFAULT_SEGMENT_MIN = 40; // minutes
// Repeat scopes
const REPEAT_SCOPE_ITEM = "item";   // (A) ponovi jedan simptom/protokol
const REPEAT_SCOPE_QUEUE = "queue"; // (B) ponovi celu Queue listu

/** iOS detection (iPhone/iPad/iPod + iPadOS masquerading as Mac) */
function isIOSDevice() {
  const ua = navigator.userAgent || "";
  const isAppleMobile = /iP(hone|od|ad)/.test(ua);
  const isIpadOS13Plus = (navigator.platform === "MacIntel" && navigator.maxTouchPoints > 1);
  return isAppleMobile || isIpadOS13Plus;
}

// 0.25s silent WAV (base64) — used to keep audio session alive on iOS when screen is off.
const SILENT_WAV_DATA_URI = "data:audio/wav;base64,UklGRkZWAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YSJWAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=";

// 0.25s audible BEEP WAV (base64) — used for iPhone one-tap self-test.
const BEEP_WAV_DATA_URI = "data:audio/wav;base64,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";

class IosAudioSessionKeeper {
  constructor(enabled) {
    this.enabled = !!enabled;
    this.audioEl = null;
    this.started = false;
  }

  _ensureEl() {
    if (this.audioEl) return this.audioEl;
    const el = document.createElement("audio");
    el.src = SILENT_WAV_DATA_URI;
    el.loop = true;
    el.preload = "auto";
    el.playsInline = true;
    el.setAttribute("playsinline", "");
    // Keep very low volume (not muted) — some iOS setups stop muted audio in background.
    el.volume = 0.0001;
    el.muted = false;
    el.style.display = "none";
    document.body.appendChild(el);
    this.audioEl = el;
    return el;
  }

  start() {
    if (!this.enabled) return;
    const el = this._ensureEl();
    // Must be triggered by a user gesture (we call this from Play click).
    try {
      const p = el.play();
      if (p && typeof p.catch === "function") p.catch(() => {});
      this.started = true;
    } catch(_) {}
  }

  stop() {
    if (!this.audioEl) return;
    try {
      this.audioEl.pause();
      this.audioEl.currentTime = 0;
    } catch(_) {}
    this.started = false;
  }
}


class App {
  constructor() {
    window.app = this;

    this.audio = new SinetAudioEngine();

    // iOS background hardening
    this._isIOS = isIOSDevice();

    // iOS: background playback in browsers is NOT guaranteed.
    // We expose an explicit (experimental) toggle for the MediaStream->HTMLAudio routing.
    this._iosBgExperimental = false;
    this._iosBgRendered = false;
    try {
      this._iosBgExperimental = (localStorage.getItem("sinet_ios_bg_experimental") === "1");
      this._iosBgRendered = (localStorage.getItem("sinet_ios_bg_rendered") === "1");
    } catch(_) {}
    // iOS: we use a silent HTMLAudio keep-alive to (a) unlock playback via user gesture and
    // (b) improve the chance that iOS keeps the session alive on lock-screen.
    // Enabled for BOTH experimental and PRO rendered modes.
    this._iosKeeper = new IosAudioSessionKeeper(this._isIOS && (this._iosBgExperimental || this._iosBgRendered));
    this._iosHintShown = false;

    // iOS: optional MediaStream -> <audio> output (best-effort)
    this._iosMediaOutEl = null;

    // iOS PRO: Rendered WAV player (<audio> src=blob:)
    this._iosRenderedEl = null;
    this._rendered = { active: false };
    this._renderedRaf = null;
    this._renderAbort = null;
    this._renderedBound = false;

    // Media Session (best-effort, varies by browser/iOS)
    this._mediaSessionReady = false;

    // Heartbeat that tries to keep AudioContext resumed while playing (best-effort)
    this._ctxHeartbeat = null;
    this.db = window.db;

    this.catalogItems = [];
    this._catalogLoad = { state: "init", err: null, count: 0, url: null, ts: 0 };
    this.playlist = [];
    this.isPlaylistActive = false;
    this.currentPlaylistIndex = 0;

    this.protocolTotalTimeSec = 0;
    this.protocolBaseElapsedSec = 0;

    // v15.7.1.5 — Repeat/Loop controls (default: (A) "lekarski" — jedan simptom)
    this.repeat = {
      scope: REPEAT_SCOPE_ITEM,
      infinite: false,
      count: 1,        // N
      remaining: 1,    // runtime counter
      cycle: 1,        // current cycle number (1-based)
      totalCycles: 1
    };

    // v15.7.1.5 — Repeat runtime + protocol timer control
    this._repeatRt = { baseProtocolSec: 0, queueCycle: 1, itemCycle: 1 };
    this._protocolTimerEnabled = true;

    // v15.7.1.5 — iOS PRO segmented rendered playback buffers
    this._renderSeg = {
      enabled: true,
      segMin: DEFAULT_SEGMENT_MIN,
      // runtime
      active: false,
      itemTotalSec: 0,
      perFreqSec: 0,
      startOffsetSec: 0,
      // pre-rendered next
      next: null, // { url, bytes, totalSec, segmentState }
      preparing: false
    };

    this.selectedItem = null;
    this.currentModalId = null;

    this._lastStats = null;

    this.ui = {};

    this.acupressureRegistry = null;
    this._modalItem = null;

    // v15.3 — Senior presets + user symptoms + overrides
    this.seniorPresets = null;
    this.seniorShowAll = false;
    this.activeOblast = null;
    this.lastCatalogViewItems = null;
    this.lastCatalogViewTitle = "";

    this.userSymptoms = [];
    this.overrides = {};

    // Nav helpers (elder-friendly)
    this.currentPageId = 'home';
    this.navStack = [];
    this._toastTimer = null;



    // v15.5 — Moji Protokoli (user-defined frequency sequences)
    this.protocols = [];
    this._protoEdit = null;
    // v15.4.7 — cached favorite IDs
    this._favSet = new Set();
  }

  async init() {
    console.log('SINET v15.7.1.5 Init');
    this.cacheUI();

    // v15.7.1.5 — restore Loop/Repeat settings (dock + playlist + modal)
    try { this._restoreRepeatFromStorage(); } catch(_) {}

    try {
      const cb = document.getElementById('ios-bg-toggle');
      if (cb) cb.checked = this.isIosBgExperimentalEnabled();
      const cb2 = document.getElementById('ios-bg-render-toggle');
      if (cb2) cb2.checked = this.isIosBgRenderedEnabled();
      const card = document.getElementById('ios-settings-card');
      if (card && !this._isIOS) card.style.display = 'none';
    } catch(_) {}

    // iOS / background / lock-screen best-effort helpers
    this._setupMediaSession();
    this._bindBackgroundRecovery();

    // ✅ ensure DB ready BEFORE any favorites / playlist read
    if (this.db) await this.db.init();


    // v15.4.7 — preload favorites set for fast UI toggles
    await this.refreshFavoritesSet();
    await this.loadCatalogData();
    await this.loadPlaylistFromDB();
    await this.loadProtocolsFromDB();

    // optional offline registry (images, licensing)
    await this.loadAcupressureRegistry();

    // v15.3 — load senior presets + user symptoms + overrides (never break init)
    await this.loadSeniorPresets();
    await this.loadUserSymptoms();
    await this.loadOverrides();
    this.applyUserDataToCatalog();

    this.renderSystemPresets();
    this.showCatalogHome();
    this.renderPlaylistUI();

    // Engine hooks
    this.audio.onTick = (stats) => this.onAudioTick(stats);
    this.audio.onComplete = () => this.onAudioComplete();
    this.audio.onSkip = (freqObj, stats) => this.onAudioSkip(freqObj, stats);
    this.audio.onFreqChange = (freqObj, stats) => this.onFreqChange(freqObj, stats);

    await this.renderResumeHint();
    
// iOS UX: show 🍏 iPhone MODE button only on iOS devices
try {
  const b1 = document.getElementById("iphone-mode-btn");
  if (b1) b1.style.display = this._isIOS ? "inline-flex" : "none";
} catch(_) {}
    this.log("APP", "Init", "OK");
  }

// iOS/Safari: explicit user-gesture unlock (now with an audible self-test)
async unlockAudio() {
  try { this.audio.init(); } catch(_) {}
  try { this._ensurePlaybackSession(); } catch(_) {}

  // Best-effort: start iOS keeper (must be user gesture)
  try {
    if (this._isIOS && this._iosKeeper) {
      this._iosKeeper.enabled = true;
      this._iosKeeper.start();
    }
  } catch(_) {}

  const res = await this._iosAudioSelfTest();

  if (res.ok) {
    try {
      const b = document.getElementById("unlock-audio-btn");
      if (b) b.style.display = "none";
    } catch(_) {}
    this.showToast("✅ iPhone/Safari: audio je aktiviran. Sada možeš ▶ POKRENI.", { timeoutMs: 6000 });
  } else {
    this.showToast("❌ iPhone: nema zvuka. Proveri 🔇 silent switch + Volume, pa tapni 🍏 iPhone MODE.", { timeoutMs: 12000 });
    try {
      const b = document.getElementById("unlock-audio-btn");
      if (b) b.style.display = "inline-flex";
    } catch(_) {}
  }

  try { this._showIosDiag(res.detail); } catch(_) {}
}

// 🍏 One-tap iPhone Mode: enables best web-only background path + runs self-test
async iphoneMode() {
  try { this.setIosBgExperimentalEnabled(false); } catch(_) {}
  try { this.setIosBgRenderedEnabled(true); } catch(_) {}

  try { this.audio.init(); } catch(_) {}
  try { this._ensurePlaybackSession(); } catch(_) {}

  // Must be within user gesture
  try {
    if (this._isIOS && this._iosKeeper) {
      this._iosKeeper.enabled = true;
      this._iosKeeper.start();
    }
  } catch(_) {}

  try {
    const btn = document.getElementById("iphone-mode-btn");
    if (btn) btn.classList.add("active");
  } catch(_) {}

  const res = await this._iosAudioSelfTest();

  if (res.ok) {
    this.showToast("🍏 iPhone MODE: uključen ✅  Sada izaberi simptom i pritisni ▶ POKRENI.", { timeoutMs: 9000 });
    try { const b = document.getElementById("unlock-audio-btn"); if (b) b.style.display = "none"; } catch(_) {}
  } else {
    this.showToast("🍏 iPhone MODE: iOS još blokira zvuk ❌  1) isključi 🔇 silent switch 2) pojačaj Volume 3) ponovi 🍏 MODE.", { timeoutMs: 14000 });
    try { const b = document.getElementById("unlock-audio-btn"); if (b) b.style.display = "inline-flex"; } catch(_) {}
  }

  try { this._showIosDiag(res.detail); } catch(_) {}
}

async _iosAudioSelfTest() {
  const detail = {
    isIOS: !!this._isIOS,
    ua: (navigator.userAgent || "").slice(0, 160),
    ctxState: null,
    ios: {
      proRendered: !!this.isIosBgRenderedEnabled?.(),
      experimental: !!this.isIosBgExperimentalEnabled?.()
    },
    catalog: null,
    webAudio: { ok: false, err: null },
    htmlAudio: { ok: false, err: null },
    prime: { renderedEl: false, mediaOutEl: false, err: null }
  };

  // Snapshot catalog state (useful when clicks do nothing because catalog isn't loaded)
  try {
    const c = this._catalogLoad || {};
    detail.catalog = {
      state: c.state || "unknown",
      count: Number(c.count || 0),
      url: c.url || null,
      err: c.err || null
    };
  } catch(_) {}

  // WebAudio beep (may be muted by iOS silent switch)
  try {
    this.audio.init();
    const ctx = this.audio.audioContext;
    detail.ctxState = ctx ? ctx.state : null;
    if (ctx && ctx.state === "suspended") {
      await ctx.resume().catch(() => {});
      detail.ctxState = ctx.state;
    }
    if (ctx) {
      const osc = ctx.createOscillator();
      osc.type = "sine";
      osc.frequency.value = 440;

      const g = ctx.createGain();
      g.gain.value = 0.55;

      osc.connect(g);
      g.connect(ctx.destination);

      osc.start();
      osc.stop(ctx.currentTime + 0.18);

      detail.webAudio.ok = true;
    }
  } catch (e) {
    detail.webAudio.ok = false;
    detail.webAudio.err = String(e?.message || e);
  }

  // HTMLAudio beep (should play even with silent switch off; varies by device settings)
  try {
    const a = new Audio(BEEP_WAV_DATA_URI);
    a.preload = "auto";
    a.loop = false;
    a.playsInline = true;
    a.setAttribute && a.setAttribute("playsinline", "");
    a.volume = 1.0;
    a.muted = false;

    const p = a.play();
    if (p && typeof p.then === "function") await p;
    setTimeout(() => { try { a.pause(); } catch(_) {} }, 300);

    detail.htmlAudio.ok = true;
  } catch (e) {
    detail.htmlAudio.ok = false;
    detail.htmlAudio.err = String(e?.message || e);
  }

  // IMPORTANT: Prime the SAME hidden <audio> elements that will later be used for iOS playback.
  // iOS sometimes unlocks playback per-element; priming a different element may not help.
  try {
    if (this._isIOS) {
      if (detail.ios.proRendered) {
        const el = this._ensureIosRenderedEl();
        el.src = SILENT_WAV_DATA_URI;
        el.loop = true;
        el.preload = "auto";
        el.playsInline = true;
        el.setAttribute && el.setAttribute("playsinline", "");
        el.volume = 0.0001;
        el.muted = false;

        const pr = el.play();
        if (pr && pr.catch) await pr.catch(() => {});
        detail.prime.renderedEl = true;
      }

      if (detail.ios.experimental && !detail.ios.proRendered) {
        const el2 = this._ensureIosMediaOutEl();
        // prime with silent src; later we switch to srcObject
        el2.src = SILENT_WAV_DATA_URI;
        el2.loop = true;
        el2.preload = "auto";
        el2.playsInline = true;
        el2.setAttribute && el2.setAttribute("playsinline", "");
        el2.volume = 0.0001;
        el2.muted = false;

        const pm = el2.play();
        if (pm && pm.catch) await pm.catch(() => {});
        detail.prime.mediaOutEl = true;
      }
    }
  } catch (e) {
    detail.prime.err = String(e?.message || e);
  }

  // Refresh catalog snapshot post-actions
  try {
    const c = this._catalogLoad || {};
    detail.catalog = {
      state: c.state || "unknown",
      count: Number(c.count || 0),
      url: c.url || null,
      err: c.err || null
    };
  } catch(_) {}

  return { ok: !!(detail.webAudio.ok || detail.htmlAudio.ok), detail };
}

_showIosDiag(detail) {
  if (!detail) return;
  const boxId = "ios-diag-box";
  let box = document.getElementById(boxId);
  if (!box) {
    box = document.createElement("div");
    box.id = boxId;
    box.style.position = "fixed";
    box.style.left = "12px";
    box.style.right = "12px";
    box.style.bottom = "110px";
    box.style.zIndex = "9999";
    box.style.background = "rgba(20,20,20,0.92)";
    box.style.color = "#fff";
    box.style.padding = "10px 12px";
    box.style.borderRadius = "14px";
    box.style.fontFamily = "monospace";
    box.style.fontSize = "12px";
    box.style.maxHeight = "22vh";
    box.style.overflow = "auto";
    box.style.boxShadow = "0 10px 25px rgba(0,0,0,0.35)";
    box.addEventListener("click", () => { try { box.remove(); } catch(_) {} });
    document.body.appendChild(box);
  }

  const lines = [];
  lines.push("🍏 iOS DIAG (tap to close)");
  lines.push("ctx=" + (detail.ctxState || "n/a") +
    " webAudio=" + (detail.webAudio?.ok ? "OK" : "FAIL") +
    " htmlAudio=" + (detail.htmlAudio?.ok ? "OK" : "FAIL") +
    " catalog=" + ((detail.catalog?.state || "n/a") + ":" + (detail.catalog?.count ?? "0")) +
    " pro=" + (detail.ios?.proRendered ? "1" : "0") +
    " exp=" + (detail.ios?.experimental ? "1" : "0") +
    " primeR=" + (detail.prime?.renderedEl ? "1" : "0") +
    " primeM=" + (detail.prime?.mediaOutEl ? "1" : "0")
  );
  if (detail.webAudio && detail.webAudio.err) lines.push("webAudio.err=" + detail.webAudio.err);
  if (detail.htmlAudio && detail.htmlAudio.err) lines.push("htmlAudio.err=" + detail.htmlAudio.err);
  lines.push("UA=" + (detail.ua || ""));
  box.textContent = lines.join("\n");
}

  _ensureIosMediaOutEl() {
    if (this._iosMediaOutEl) return this._iosMediaOutEl;
    const el = document.createElement("audio");
    el.preload = "auto";
    el.playsInline = true;
    el.setAttribute("playsinline", "");
    el.volume = 1.0;
    el.muted = false;
    el.style.display = "none";
    document.body.appendChild(el);
    this._iosMediaOutEl = el;
    return el;
  }

  _ensureIosRenderedEl() {
    if (this._iosRenderedEl) return this._iosRenderedEl;
    const el = document.createElement("audio");
    el.preload = "auto";
    el.playsInline = true;
    el.setAttribute("playsinline", "");
    el.controls = false;
    el.volume = 1.0;
    el.muted = false;
    el.style.display = "none";
    document.body.appendChild(el);
    this._iosRenderedEl = el;
    return el;
  }

  _isRenderedPlaying() {
    try {
      const el = this._iosRenderedEl;
      return !!(el && this._rendered && this._rendered.active && !el.paused && !el.ended);
    } catch(_) { return false; }
  }
  async _startRenderedTrack(params = {}) {
    // params: { sequence, durationsSec, totalSec, resumeTrackSec, titleText, loopAll, segmentMin }
    if (!this._isIOS) throw new Error('Rendered mode is intended for iOS only.');

    const fullSeq = Array.isArray(params.sequence) ? params.sequence : [];
    const fullDurs = Array.isArray(params.durationsSec) ? params.durationsSec : null;
    const fullTotalSec = Math.max(0, Number(params.totalSec) || 0);
    const resumeTrackSec = Math.max(0, Number(params.resumeTrackSec) || 0);

    if (!fullSeq.length || !fullTotalSec) throw new Error('Empty rendered track.');

    const segMin = Math.max(5, Number(params.segmentMin) || Number(this._renderSeg?.segMin) || DEFAULT_SEGMENT_MIN);
    const segLenSec = segMin * 60;

    try { this.audio?.stop?.(); } catch(_) {}
    try { this._teardownPlaybackSession('render_start'); } catch(_) {}

    const el = this._ensureIosRenderedEl();

    try {
      if (this._iosKeeper) {
        this._iosKeeper.enabled = true;
        this._iosKeeper.start();
      }
    } catch(_) {}

    try { if (this._renderAbort) this._renderAbort.abort(); } catch(_) {}
    this._renderAbort = new AbortController();

    if (this.ui.playerDock) { this.ui.playerDock.style.display = 'block'; requestAnimationFrame(() => this._syncDockPadding(false)); }
    if (this.ui.nowPlayingPanel) this.ui.nowPlayingPanel.style.display = 'block';
    if (this.ui.btnPlayPause) this.ui.btnPlayPause.innerText = '⏳';

    const r = await this._startRenderedSegment({
      fullSeq,
      fullDurs,
      fullTotalSec,
      resumeTrackSec,
      segLenSec,
      titleText: (params.titleText || '').toString(),
      signal: this._renderAbort.signal
    });

    return r;
  }

  _durationAt(i, fullDurs, perStep) {
    try {
      if (fullDurs && fullDurs.length) return Math.max(0, Number(fullDurs[i]) || 0);
      return Math.max(0, perStep);
    } catch (_) {
      return Math.max(0, perStep);
    }
  }

  _computeRenderedSegment(fullSeq, fullDurs, fullTotalSec, resumeTrackSec, segLenSec) {
    const n = fullSeq.length;
    const perStep = n ? (fullTotalSec / n) : 0;

    let startIdx = 0;
    let startOffset = 0;
    for (let i = 0; i < n; i++) {
      const d = this._durationAt(i, fullDurs, perStep);
      if (resumeTrackSec < startOffset + d) { startIdx = i; break; }
      startOffset += d;
      startIdx = Math.min(n - 1, i + 1);
    }

    startIdx = Math.max(0, Math.min(n - 1, startIdx));

    let endIdx = startIdx;
    let segTotal = 0;
    for (let i = startIdx; i < n; i++) {
      const d = this._durationAt(i, fullDurs, perStep);
      segTotal += d;
      endIdx = i;
      if (segTotal >= segLenSec && i > startIdx) break;
    }

    const segSeq = fullSeq.slice(startIdx, endIdx + 1);
    const segDurs = fullDurs ? fullDurs.slice(startIdx, endIdx + 1) : null;

    const resumeInSeg = Math.max(0, resumeTrackSec - startOffset);
    const endOffset = Math.min(fullTotalSec, startOffset + segTotal);

    return {
      startIdx,
      endIdx,
      startOffsetSec: startOffset,
      endOffsetSec: endOffset,
      segSeq,
      segDurs,
      segTotalSec: Math.max(0, segTotal),
      resumeInSegSec: resumeInSeg
    };
  }

  async _startRenderedSegment({ fullSeq, fullDurs, fullTotalSec, resumeTrackSec, segLenSec, titleText, signal }) {
    const el = this._ensureIosRenderedEl();

    const seg = this._computeRenderedSegment(fullSeq, fullDurs, fullTotalSec, resumeTrackSec, segLenSec);

    const estBytes = estimateWavBytes(seg.segTotalSec, 22050, 1, 16);
    const estMB = estBytes / (1024 * 1024);
    const HARD_MB = 160;
    if (estMB > HARD_MB) {
      this.showToast(`⚠️ iOS PRO: Segment je prevelik za RAM render (~${estMB.toFixed(0)} MB). Prelazim na standardni režim (foreground).`, { timeoutMs: 10000 });
      this._iosBgRendered = false;
      try { localStorage.setItem('sinet_ios_bg_rendered', '0'); } catch (_) {}
      try { const el2 = document.getElementById('ios-bg-render-toggle'); if (el2) el2.checked = false; } catch (_) {}
      try { this._hideStartOverlay(); this._setStartButtonsEnabled(true); } catch (_) {}
      return { fallback: true };
    }

    try {
      const fromMin = Math.floor(seg.startOffsetSec / 60);
      const toMin = Math.ceil(Math.min(fullTotalSec, seg.endOffsetSec) / 60);
      this.showToast(`🍏 iOS PRO: Renderujem segment ${fromMin}–${toMin} min (~${estMB.toFixed(0)} MB)`, { timeoutMs: 4500 });
    } catch (_) {}

    let rendered;
    try {
      rendered = await renderProtocolToWavBlobURL({
        sequence: seg.segSeq,
        durationsSec: seg.segDurs,
        totalSec: seg.segTotalSec,
        sampleRate: 22050,
        channels: 1,
        gain: (this.audio?.masterGain?.gain?.value) ? Math.max(0.05, Math.min(0.9, this.audio.masterGain.gain.value)) : 0.25,
        subCarrierHz: this.audio?.subCarrierHz || 200,
        subThresholdHz: this.audio?.subCarrierThresholdHz || 50,
        fadeMs: 12,
        signal
      });
    } catch (e) {
      this.showToast('❌ iOS PRO: render nije uspeo. Vraćam standardni režim.', { timeoutMs: 9000 });
      try { this._hideStartOverlay(); this._setStartButtonsEnabled(true); } catch (_) {}
      return { fallback: true, error: String(e?.message || e) };
    }

    try {
      if (this._rendered && this._rendered.url) URL.revokeObjectURL(this._rendered.url);
    } catch (_) {}

    el.src = rendered.url;
    el.loop = false;
    try { el.currentTime = Math.max(0, seg.resumeInSegSec); } catch (_) {}

    this._rendered = {
      active: true,
      url: rendered.url,
      bytes: rendered.bytes,
      totalSec: seg.segTotalSec,
      fullTotalSec,
      sampleRate: rendered.sampleRate,
      channels: rendered.channels,
      sequence: seg.segSeq,
      durationsSec: seg.segDurs,
      fullSequence: fullSeq,
      fullDurationsSec: fullDurs,
      segStartIndex: seg.startIdx,
      segEndIndex: seg.endIdx,
      segStartOffsetSec: seg.startOffsetSec,
      segEndOffsetSec: seg.endOffsetSec,
      lastIndex: -1,
      titleText: titleText || ''
    };

    // Fill "FREKVENCIJE" panel immediately (iOS PRO rendered mode)
    try { this.renderNowPlayingList({ currentIndex: Number(this._rendered.segStartIndex||0) }); } catch(_) {}


    if (!this._renderedBound) {
      this._renderedBound = true;
      el.addEventListener('ended', () => {
        try { this._handleRenderedEnded(); } catch (_) {}
      });
    }

    this._startRenderedTicker();

    try {
      const p = el.play();
      if (p && typeof p.catch === 'function') {
        p.catch(() => {
          try {
            this.showToast('🍏 iPhone blokira ▶ dok se audio ne aktivira. Tapni 🔊 AKTIVIRAJ, pa opet ▶.', { timeoutMs: 12000 });
            const b = document.getElementById('unlock-audio-btn');
            if (b) b.style.display = 'inline-flex';
          } catch (_) {}
        });
      }
    } catch (_) {}

    if (this.ui.btnPlayPause) this.ui.btnPlayPause.innerText = '⏸';

    try { this._hideStartOverlay(); this._setStartButtonsEnabled(true); } catch (_) {}

    this.log('PLAYER', 'Play (iOS PRO Rendered Seg)', this.selectedItem?.id || '');

    return { fallback: false };
  }

  async _handleRenderedEnded() {
    try {
      if (!this._rendered || !this._rendered.active) return;

      const nextResume = Number(this._rendered.segEndOffsetSec) || 0;
      const fullTotal = Number(this._rendered.fullTotalSec) || Number(this._rendered.totalSec) || 0;

      if (nextResume >= (fullTotal - 0.01)) {
        this._rendered.active = false;
        this.onAudioComplete();
        return;
      }

      try {
        this._showStartOverlay('⏳ PRIPREMAM…', 'Sledeći segment (iOS PRO)…');
        this._setStartButtonsEnabled(false);
      } catch (_) {}

      await this._startRenderedSegment({
        fullSeq: this._rendered.fullSequence || [],
        fullDurs: this._rendered.fullDurationsSec || null,
        fullTotalSec: fullTotal,
        resumeTrackSec: nextResume,
        segLenSec: Math.max(5*60, Number(this._renderSeg?.segMin || DEFAULT_SEGMENT_MIN) * 60),
        titleText: this._rendered.titleText || '',
        signal: (this._renderAbort && this._renderAbort.signal) ? this._renderAbort.signal : undefined
      });
    } catch (e) {
      try { this._rendered.active = false; } catch (_) {}
      try { this._hideStartOverlay(); this._setStartButtonsEnabled(true); } catch (_) {}
      this.onAudioComplete();
    }
  }

  _startRenderedTicker() {
    if (this._renderedRaf) cancelAnimationFrame(this._renderedRaf);
    const el = this._iosRenderedEl;

    const loop = () => {
      try {
        if (!this._rendered || !this._rendered.active || !el) return;
        if (document.hidden) { this._renderedRaf = requestAnimationFrame(loop); return; }

        const tSeg = Math.max(0, Number(el.currentTime) || 0);
        const base = Math.max(0, Number(this._rendered.segStartOffsetSec) || 0);
        const tFull = Math.max(0, Math.min((Number(this._rendered.fullTotalSec) || 0), base + tSeg));

        const seqFull = this._rendered.fullSequence || this._rendered.sequence || [];
        const dursFull = this._rendered.fullDurationsSec || this._rendered.durationsSec;
        const fullTotalSec = Number(this._rendered.fullTotalSec || this._rendered.totalSec || 0);
        const perStep = (!dursFull && seqFull.length) ? (fullTotalSec / seqFull.length) : 0;

        let idx = 0;
        let acc = 0;
        for (; idx < seqFull.length; idx++) {
          const d = dursFull ? (Number(dursFull[idx]) || 0) : perStep;
          if (tFull < acc + d) break;
          acc += d;
        }
        idx = Math.min(idx, Math.max(0, seqFull.length - 1));
        const durCur = dursFull ? (Number(dursFull[idx]) || 0) : perStep;
        const elapsedInFreq = Math.max(0, tFull - acc);

        const stats = {
          currentIndex: idx,
          totalItems: seqFull.length,
          enabledTotalItems: seqFull.length,
          currentPos: idx,
          elapsedInFreq,
          durationPerFreq: durCur,
          durationCurrentSec: durCur,
          totalDurationSec: fullTotalSec,
          totalTrackSec: fullTotalSec,
          elapsedTrackSec: tFull,
          hasPerFreqDurations: !!dursFull
        };

        if (this._rendered.lastIndex !== idx) {
          this._rendered.lastIndex = idx;
          this.onFreqChange(seqFull[idx] || {}, stats);
        }

        this.onAudioTick(stats);

        this._lastStats = {
          currentIndex: stats.currentIndex,
          totalItems: stats.totalItems,
          elapsedInFreq: stats.elapsedInFreq,
          durationPerFreq: stats.durationCurrentSec
        };
      } catch (_) {}

      this._renderedRaf = requestAnimationFrame(loop);
    };

    this._renderedRaf = requestAnimationFrame(loop);
  }


  _stopRenderedTrack() {
    try { if (this._renderAbort) this._renderAbort.abort(); } catch(_) {}
    try {
      const el = this._iosRenderedEl;
      if (el) { el.pause(); el.removeAttribute("src"); el.load(); }
    } catch(_) {}
    try { if (this._rendered && this._rendered.url) URL.revokeObjectURL(this._rendered.url); } catch(_) {}
    try { if (this._renderedRaf) cancelAnimationFrame(this._renderedRaf); } catch(_) {}
    this._renderedRaf = null;
    this._rendered = { active:false };
  }



  cacheUI() {
    this.ui = {
      screens: {
        home: document.getElementById('page-home'),
        catalog: document.getElementById('page-catalog'),
        playlist: document.getElementById('page-playlist'),
        protocols: document.getElementById('page-protocols'),
        favorites: document.getElementById('page-favorites'),
        mysymptoms: document.getElementById('page-mysymptoms'),
        ai: document.getElementById('page-ai'),
        help: document.getElementById('page-help'),
        settings: document.getElementById('page-settings')
      },
      catalogOblastGrid: document.getElementById('catalog-oblast-grid'),
      catalogList: document.getElementById('catalog-list'),
      userSymptomsList: document.getElementById('user-symptoms-list'),
      userSymptomForm: document.getElementById('user-symptom-form'),
      protocolsList: document.getElementById('protocols-list'),
      protocolEditor: document.getElementById('protocol-editor'),
      protocolEditorBox: document.getElementById('protocol-editor-box'),
      aiPrompt: document.getElementById('ai_prompt'),
      main: document.querySelector('main'),
      playerDock: document.getElementById('player-dock'),
      pTitle: document.getElementById('p-title'),
      pTimerNow: document.getElementById('p-timer-now'),
      pTimerElapsed: document.getElementById('p-timer-elapsed'),
      pTimerTotal: document.getElementById('p-timer-total'),
      pProtocolTimer: document.getElementById('p-protocol-timer'),
      pStatus: document.getElementById('p-status'),
      btnPlayPause: document.getElementById('btn-pp'),
      btnNowList: document.getElementById('btn-nowlist'),
      nowPlayingPanel: document.getElementById('nowplaying-panel'),
      nowPlayingList: document.getElementById('nowplaying-list'),
      pActiveHz: document.getElementById('p-active-hz'),
      pActiveName: document.getElementById('p-active-name'),
      pActiveDesc: document.getElementById('p-active-desc'),
      pActiveSrc: document.getElementById('p-active-src'),
      pActiveDur: document.getElementById('p-active-dur')
    };
  }

  _syncDockPadding(forceHide = false) {
    // iOS / mobile: ensure main content is not hidden behind the fixed player dock.
    try {
      const main = this.ui?.main || document.querySelector('main');
      if (!main) return;
      const dock = this.ui?.playerDock || document.getElementById('player-dock');

      let h = 0;
      const visible = !!dock && !forceHide && (dock.style.display !== 'none');
      if (visible) {
        h = Math.round((dock.getBoundingClientRect?.().height || dock.offsetHeight || 0));
        // fallback for first frame
        if (h < 40) h = 190;
      }
      document.documentElement.style.setProperty('--dock-h', `${h}px`);
    } catch (_) {}
  }



  /* ===================== v15.7.1.5 — Loop / Repeat (UI) ===================== */

  _readRepeatSettings(ctx = "playlist") {
    // ctx: "playlist" | "modal" | "dock"
    const isModal = (ctx === "modal");
    const isDock = (ctx === "dock");
    const idCount = isModal ? "m-repeat-count" : (isDock ? "p-repeat-count" : "pl-repeat-count");
    const idInf = isModal ? "m-repeat-infinite" : (isDock ? "p-repeat-infinite" : "pl-repeat-infinite");
    const nameScope = isModal ? "m-repeat-scope" : (isDock ? "p-repeat-scope" : "pl-repeat-scope");

    let count = 1;
    let infinite = false;
    let scope = REPEAT_SCOPE_ITEM;

    try {
      const elC = document.getElementById(idCount);
      count = Math.max(1, Math.min(200, Number(elC?.value || 1) || 1));
    } catch(_) { count = 1; }

    try { infinite = !!document.getElementById(idInf)?.checked; } catch(_) { infinite = false; }

    try {
      const el = document.querySelector(`input[name="${nameScope}"]:checked`);
      const v = (el?.value || "").toString();
      if (v === REPEAT_SCOPE_QUEUE) scope = REPEAT_SCOPE_QUEUE;
      else scope = REPEAT_SCOPE_ITEM;
    } catch(_) { scope = REPEAT_SCOPE_ITEM; }

    // Safety: if infinite + scope item + playlist mode and playlist has >1 items, user probably meant queue.
    // But do NOT override automatically — just warn subtly in status line.
    return { count, infinite, scope };
  }

  _applyRepeatSettings(s) {
    const count = Math.max(1, Number(s?.count) || 1);
    const infinite = !!s?.infinite;
    const scope = (s?.scope === REPEAT_SCOPE_QUEUE) ? REPEAT_SCOPE_QUEUE : REPEAT_SCOPE_ITEM;

    this.repeat.scope = scope;
    this.repeat.infinite = infinite;
    this.repeat.count = count;
    this.repeat.totalCycles = infinite ? Infinity : count;
    this.repeat.remaining = infinite ? Infinity : count;
    this.repeat.cycle = 1;

    try { this._renderRepeatStatus(); } catch(_) {}
  }

  _renderRepeatStatus(extra = "") {
    if (!this.ui?.pStatus) return;

    const scope = (this.repeat.scope === REPEAT_SCOPE_QUEUE) ? REPEAT_SCOPE_QUEUE : REPEAT_SCOPE_ITEM;
    const nLbl = (this.repeat.infinite) ? '∞' : String(this.repeat.count || 1);

    let cycLbl = '';
    if (scope === REPEAT_SCOPE_QUEUE) {
      const q = Math.max(1, Number(this._repeatRt?.queueCycle) || 1);
      cycLbl = this.repeat.infinite ? `Queue ciklus ${q}` : `Queue ciklus ${q}/${this.repeat.count || 1}`;
    } else {
      const ic = Math.max(1, Number(this._repeatRt?.itemCycle) || 1);
      cycLbl = this.repeat.infinite ? `Simptom ciklus ${ic}` : `Simptom ciklus ${ic}/${this.repeat.count || 1}`;
    }

    const msg = `🔁 ${cycLbl} (N=${nLbl})${extra ? ' • ' + extra : ''}`;
    this.ui.pStatus.innerText = msg;
  }

  /* ===================== v15.7.1.5 — UX overlay (“⏳ PRIPREMAM…”) ===================== */

  _showStartOverlay(text="⏳ PRIPREMAM…", sub="Sačekaj 5 sekundi…") {
    const ov = document.getElementById("start-overlay");
    const t = document.getElementById("start-overlay-text");
    const s = document.getElementById("start-overlay-sub");
    const bar = document.getElementById("start-overlay-bar");
    if (!ov) return;
    if (t) t.innerText = text;
    if (s) s.innerText = sub;
    if (bar) bar.style.width = "0%";
    ov.style.display = "flex";

    // pseudo-progress (indeterminate)
    const start = Date.now();
    const tick = () => {
      if (ov.style.display === "none") return;
      const dt = Date.now() - start;
      const pct = Math.min(92, Math.max(5, Math.floor((dt / 5200) * 92)));
      if (bar) bar.style.width = pct + "%";
      requestAnimationFrame(tick);
    };
    requestAnimationFrame(tick);
  }

  _hideStartOverlay() {
    const ov = document.getElementById("start-overlay");
    const bar = document.getElementById("start-overlay-bar");
    if (bar) bar.style.width = "100%";
    if (ov) ov.style.display = "none";
  }

  _setStartButtonsEnabled(enabled) {
    try {
      const b = document.querySelector('button.btn-full[onclick="startProtocol()"]');
      if (b) { b.disabled = !enabled; b.style.opacity = enabled ? "1" : "0.65"; }
    } catch(_) {}
    try {
      const b2 = document.getElementById("m-play-btn");
      if (b2) { b2.disabled = !enabled; b2.style.opacity = enabled ? "1" : "0.65"; }
    } catch(_) {}
  }

  /* ===================== v15.7.1.5 — Preporuka block ===================== */

  _getRecommendation(item) {
    const p = item?.preporuka || item?.preporuke || item?.recommendation || null;

    const perFreqMin = Number(
      p?.trajanje_po_frekv_min ?? p?.trajanjePoFrekvMin ?? p?.trajanjePoFrekvencijiMin ??
      item?.trajanjePoFrekvencijiMin ?? item?.trajanje_po_frekv_min ?? 5
    ) || 5;

    const loopN = Number(p?.loop_uzastopno ?? p?.loopN ?? p?.ponovi ?? 1) || 1;
    const daysN = Number(p?.dnevno_dana ?? p?.dnevnoDana ?? p?.dnevno ?? 1) || 1;
    const pauseDays = Number(p?.pauza_dana ?? p?.pauzaDana ?? p?.pauza ?? 0) || 0;

    const segMin = Number(p?.segment_min ?? p?.segmentMin ?? DEFAULT_SEGMENT_MIN) || DEFAULT_SEGMENT_MIN;

    return {
      perFreqMin: Math.max(1, perFreqMin),
      loopN: Math.max(1, loopN),
      daysN: Math.max(1, daysN),
      pauseDays: Math.max(0, pauseDays),
      segMin: Math.max(5, segMin)
    };
  }

  _renderRecommendationToModal(item) {
    const r = this._getRecommendation(item);
    try { const el = document.getElementById("m-reco-dur"); if (el) el.innerText = `${r.perFreqMin} min`; } catch(_) {}
    try { const el = document.getElementById("m-reco-loop"); if (el) el.innerText = `${r.loopN}×`; } catch(_) {}
    try { const el = document.getElementById("m-reco-days"); if (el) el.innerText = `${r.daysN}`; } catch(_) {}
    try { const el = document.getElementById("m-reco-pause"); if (el) el.innerText = `${r.pauseDays}`; } catch(_) {}
    try { const el = document.getElementById("m-reco-seg"); if (el) el.innerText = `${r.segMin}`; } catch(_) {}
  }

  _renderRecommendationToPlayer(item) {
    const box = document.getElementById("p-reco-box");
    if (!box) return;
    const r = this._getRecommendation(item);
    try { const el = document.getElementById("p-reco-dur"); if (el) el.innerText = `${r.perFreqMin} min`; } catch(_) {}
    try { const el = document.getElementById("p-reco-loop"); if (el) el.innerText = `${r.loopN}×`; } catch(_) {}
    try { const el = document.getElementById("p-reco-days"); if (el) el.innerText = `${r.daysN}`; } catch(_) {}
    try { const el = document.getElementById("p-reco-pause"); if (el) el.innerText = `${r.pauseDays}`; } catch(_) {}
    try { const el = document.getElementById("p-reco-seg"); if (el) el.innerText = `${r.segMin}`; } catch(_) {}
    box.style.display = "block";
  }

  async log(cat, action, details="") {
    try { await this.db?.logAction?.(cat, action, details); } catch(e) {}
  }

  /* ===================== DATA ===================== */
  
async loadCatalogData(force = false) {
  const loader = document.getElementById('loader');
  const loaderText = document.getElementById('loader-text') || loader;
  const loaderRetry = document.getElementById('loader-retry');
  const loaderDetail = document.getElementById('loader-detail');

  // Track state for iOS diag / UX
  try {
    this._catalogLoad = this._catalogLoad || { state: "init", err: null, count: 0, url: null, ts: 0 };
    this._catalogLoad.state = "loading";
    this._catalogLoad.err = null;
    this._catalogLoad.count = 0;
    this._catalogLoad.url = null;
    this._catalogLoad.ts = Date.now();
  } catch(_) {}

  if (loaderRetry) loaderRetry.style.display = "none";
  if (loaderDetail) loaderDetail.style.display = "none";
  if (loaderText) loaderText.innerText = "⏳ Učitavam katalog iz /data/...";

  // Prefer canonical STL if present, fallback to runtime catalog
  const candidates = [
    'data/SINET_STL.json',
    'data/SINET_CATALOG.json'
  ];

  let lastErr = null;
  for (const url of candidates) {
    try {
      // cache-bust on force
      const u = force ? (url + (url.includes('?') ? '&' : '?') + 't=' + Date.now()) : url;
      const res = await fetch(u, { cache: "no-store" });
      if (!res.ok) throw new Error(`${url} nije pronađen (${res.status})`);
      const raw = await res.json();

      const norm = normalizeCatalogPayload(raw);
      this.catalogItems = Array.isArray(norm.items) ? norm.items : [];

      // v15.3 — keep canonical core list (without user additions/overrides)
      this.catalogCoreItems = this.catalogItems.slice();

      if (loader) loader.style.display = 'none';

      try {
        this._catalogLoad.state = "ok";
        this._catalogLoad.err = null;
        this._catalogLoad.count = this.catalogItems.length;
        this._catalogLoad.url = url;
        this._catalogLoad.ts = Date.now();
      } catch(_) {}

      this.log("DATA", "Catalog Loaded", `${this.catalogItems.length} • ${url}`);
      return;
    } catch (e) {
      lastErr = e;
    }
  }

  // All failed
  const msg = "GREŠKA: " + (lastErr?.message || "Catalog load failed");
  if (loaderText) loaderText.innerText = msg;
  if (loaderRetry) loaderRetry.style.display = "inline-flex";
  if (loaderDetail) {
    loaderDetail.style.display = "block";
    loaderDetail.innerText = "Saveti: 1) osveži stranicu 2) otvori /index-nosw.html 3) proveri da li fajlovi postoje u /data/.";
  }

  try {
    this._catalogLoad.state = "err";
    this._catalogLoad.err = String(lastErr?.message || lastErr || "unknown");
    this._catalogLoad.count = 0;
    this._catalogLoad.url = null;
    this._catalogLoad.ts = Date.now();
  } catch(_) {}

  console.error(lastErr);
  this.log("ERROR", "Catalog Load Failed", lastErr?.message || "");
}

async loadAcupressureRegistry() {
  // Optional offline registry (images/licensing). Must NEVER break init.
  const url = 'data/media/acupressure/registry.json';
  try {
    const res = await fetch(url, { cache: "no-store" });
    if (!res.ok) throw new Error(`${url} nije pronađen (${res.status})`);
    this.acupressureRegistry = await res.json();
    this.log("DATA", "Acupressure Registry Loaded", url);
  } catch (e) {
    this.acupressureRegistry = null;
    console.warn("Acupressure registry not loaded:", e?.message || e);
    this.log("DATA", "Acupressure Registry Missing", e?.message || "unknown");
  }
}

  // Manual retry (useful on iOS / SW-cache issues)
  async retryCatalog() {
    this.showToast("🔄 Pokušavam ponovo da učitam katalog...", { timeoutMs: 3500 });
    await this.loadCatalogData(true);
    try { this.renderSystemPresets(); } catch(_) {}
    try { if (this.currentPageId === 'catalog') this.showCatalogHome(); } catch(_) {}
    try { if (this.catalogItems && this.catalogItems.length) this.showToast(`✅ Katalog učitan (${this.catalogItems.length}).`, { timeoutMs: 3500 }); } catch(_) {}
  }

  /* ===================== NAV ===================== */
  nav(pageId, opts = {}) {
    const prev = this.currentPageId || 'home';
    const replace = opts.replace === true;
    const stack = opts.stack !== false;

    if (!replace && stack && prev && prev !== pageId) {
      this.navStack.push(prev);
      if (this.navStack.length > 40) this.navStack.shift();
    }

    this.currentPageId = pageId;

    Object.values(this.ui.screens).forEach(s => s?.classList?.remove('active'));
    document.getElementById('page-' + pageId)?.classList?.add('active');

    const ov = document.getElementById('nav-overlay');
    if (ov) ov.style.display='none';

    this.log("UI", "Nav", pageId);

    // Page-specific refresh
    if (pageId === 'favorites') this.updateFavorites();
    if (pageId === 'catalog') this.showCatalogHome();
    if (pageId === 'playlist') this.renderPlaylistUI();
    if (pageId === 'protocols') this.renderProtocolsUI();
    if (pageId === 'mysymptoms') this.renderUserSymptomsUI();
    if (pageId === 'ai') this.prepareAIUI();
  }

  goBack() {
    const prev = this.navStack.pop();
    this.nav(prev || 'home', { replace: true, stack: false });
  }

  showToast(msg, opts = {}) {
    const el = document.getElementById('toast') || this._createToast();
    if (!el) return;

    const actionLabel = (opts.actionLabel || '').toString();
    const actionNav = (opts.actionNav || '').toString();

    const action2Label = (opts.action2Label || '').toString();
    const action2Onclick = (opts.action2Onclick || '').toString();

    el.innerHTML = `
      <div class="toast-msg">${this.escapeHtml(String(msg||''))}</div>
      ${actionLabel && actionNav ? `<button class="toast-btn" onclick="nav('${actionNav}'); window.app && window.app.hideToast && window.app.hideToast()">${this.escapeHtml(actionLabel)}</button>` : ''}
      ${action2Label && action2Onclick ? `<button class="toast-btn" onclick="${action2Onclick}; window.app && window.app.hideToast && window.app.hideToast()">${this.escapeHtml(action2Label)}</button>` : ''}
      <button class="toast-x" onclick="window.app && window.app.hideToast && window.app.hideToast()" aria-label="Zatvori">✕</button>
    `;

    el.style.display = 'flex';

    if (this._toastTimer) clearTimeout(this._toastTimer);
    this._toastTimer = setTimeout(() => this.hideToast(), Number(opts.timeoutMs) || 3800);
  }

  hideToast() {
    const el = document.getElementById('toast');
    if (el) el.style.display = 'none';
    if (this._toastTimer) {
      clearTimeout(this._toastTimer);
      this._toastTimer = null;
    }
  }

  _createToast() {
    const d = document.createElement('div');
    d.id = 'toast';
    d.className = 'toast';
    d.style.display = 'none';
    document.body.appendChild(d);
    return d;
  }


  /* ===================== PLAYLIST (DB) ===================== */
  async loadPlaylistFromDB() {
    try {
      this.playlist = await this.db?.getMainPlaylist?.() || [];
      if (!Array.isArray(this.playlist)) this.playlist = [];
      this.log("DATA", "Playlist Loaded", String(this.playlist.length));
    } catch(e) {
      this.playlist = [];
      this.log("ERROR", "Playlist Load Failed", e.message);
    }
  }

  async savePlaylistToDB() {
    try { await this.db?.saveMainPlaylist?.(this.playlist); } catch(e) {}
  }

  /* ===================== AUDIO UI ===================== */

  onFreqChange(freqObj, stats) {
    this._lastStats = stats;
    this._updateMediaSessionMetadata(freqObj, stats);

    const hz = Number(freqObj?.value ?? freqObj?.hz) || 0;
    const idx = (stats?.currentIndex ?? 0) + 1;
    const total = stats?.totalItems ?? 0;

    const isSub = hz > 0 && hz < 50;
    const carrierNote = isSub ? ` <span class="muted">(noseći 200 Hz)</span>` : "";

        const naziv = (freqObj?.naziv || "").toString().trim();
    const opis = (freqObj?.opis || "").toString().trim();
    const funkcija = (freqObj?.funkcija || freqObj?.svrha || "").toString().trim();

    const shortLabel = (funkcija || naziv || "").toString().trim();
    // Backward compatibility: some runtime lists only have svrha/desc
    const legacyLabel = (freqObj?.svrha || freqObj?.desc || "").toString().trim();
    const desc = (shortLabel || legacyLabel || "").toString().trim();

    const srcObj = (freqObj?.izvor_obj || freqObj?.izvor || freqObj?.src || null);
    const srcText = this._srcToText(srcObj);

    const recMinRaw = (freqObj?.trajanje_min ?? freqObj?.preporuceno_min ?? freqObj?.preporucenoMin ?? null);
    const recMin = (recMinRaw === null || recMinRaw === undefined || recMinRaw === "") ? null : Math.max(0, Number(recMinRaw) || 0);

    const curDurSec = (stats && Number.isFinite(Number(stats.durationCurrentSec))) ? Number(stats.durationCurrentSec) : (Number(stats?.durationPerFreq) || 0);
    const currentMin = curDurSec / 60;
    const fmtMin = (v) => {
      const n = Math.max(0, Number(v) || 0);
      if (!n) return "0";
      // show .5 if needed
      const r = Math.round(n * 2) / 2;
      return (r % 1 === 0) ? String(Math.round(r)) : String(r);
    };

    // === Player active meta (STL) ===
    if (this.ui.pActiveHz) this.ui.pActiveHz.innerText = `${hz} Hz${isSub ? " (noseći 200 Hz)" : ""}`;
    if (this.ui.pActiveName) this.ui.pActiveName.innerText = desc ? `— ${desc}` : "";
    if (this.ui.pActiveDesc) this.ui.pActiveDesc.textContent = opis ? `ℹ️ ${opis}` : "ℹ️ Opis frekvencije nije popunjen (još).";

    // Source as link if possible
    let srcHtml = "";
    if (srcObj && typeof srcObj === "object") {
      const url = (srcObj.url || srcObj.URL || srcObj.link || "").toString().trim();
      if (url) srcHtml = `📎 Izvor: <a href="${this.escapeAttr(url)}" target="_blank" rel="noopener noreferrer">${this.escapeHtml(url)}</a>`;
    }
    if (!srcHtml && srcText) {
      const looksUrl = /^https?:\/\//i.test(srcText);
      srcHtml = looksUrl
        ? `📎 Izvor: <a href="${this.escapeAttr(srcText)}" target="_blank" rel="noopener noreferrer">${this.escapeHtml(srcText)}</a>`
        : `📎 Izvor: ${this.escapeHtml(srcText)}`;
    }
    if (this.ui.pActiveSrc) this.ui.pActiveSrc.innerHTML = srcHtml || "📎 Izvor: —";

    const durLine = recMin && recMin > 0
      ? `⏱ Preporučeno: ${fmtMin(recMin)} min • Trenutno: ${fmtMin(currentMin)} min`
      : `⏱ Trenutno: ${fmtMin(currentMin)} min • Preporučeno: nije popunjeno`;
    if (this.ui.pActiveDur) this.ui.pActiveDur.textContent = durLine;

    const nextObj = (this.audio.currentSequence || [])[stats.currentIndex + 1];
    const nextHz = nextObj ? (Number(nextObj.value ?? nextObj.hz) || 0) : null;
    const nextIsSub = nextHz !== null && nextHz > 0 && nextHz < 50;

    const nextDesc = nextObj ? (nextObj?.svrha || nextObj?.funkcija || nextObj?.desc || nextObj?.naziv || "").toString().trim() : "";
    const nextLine = nextHz !== null
      ? `⏭ Sledeće: <b>${nextHz} Hz</b>${nextIsSub ? ` <span class="muted">(noseći 200 Hz)</span>` : ""}${nextDesc ? ` <span class="muted">— ${this.escapeHtml(nextDesc)}</span>` : ""}`
      : `⏭ Sledeće: kraj`;

    // Alternative = naredne 2-3 frekvencije posle sledeće
    const alt = [];
    const seq = this.audio.currentSequence || [];
    for (let j = (stats?.currentIndex ?? 0) + 2; j < Math.min(seq.length, (stats?.currentIndex ?? 0) + 5); j++) {
      const o = seq[j] || {};
      const hz2 = Number(o.value ?? o.hz) || 0;
      if (!hz2) continue;
      alt.push(`${hz2} Hz`);
    }

    // Symptom meta (uniformno za Listu / Favorite / Katalog)
    const it = this.selectedItem || null;
    const sName = (it?.simptom || "").toString().trim();
    const sDesc = (it?.opis || it?.desc || it?.description || "").toString().trim();
    const mkbCode = this.getMKB10Code(it?.mkb10);
    const mkbDesc = this.getMKB10Desc(it?.mkb10);
    const mkbUrl = this.getMKB10Url(it?.mkb10);
    const mkbSys = (it?.mkb10?.izvor?.sistem || it?.mkb10?.izvor?.system || "").toString().trim();

    const mkbMain = (mkbCode || mkbDesc)
      ? `${this.escapeHtml(mkbCode || "")}${(mkbCode && mkbDesc) ? " — " : ""}${this.escapeHtml(mkbDesc || "")}${mkbSys ? ` <span class="muted">(${this.escapeHtml(mkbSys)})</span>` : ""}`
      : `<span class="muted">nije popunjeno</span>`;

    const mkbLink = mkbUrl
      ? `<span class="line muted">🔗 Izvor MKB-10: <a href="${this.escapeAttr(mkbUrl)}" target="_blank" rel="noopener noreferrer">otvori</a></span>`
      : "";

    const descLine = `<span class="line muted">ℹ️ ${this.escapeHtml(desc || "Opis frekvencije nije unet.")}</span>`;
    const srcLine  = srcText ? `<span class="line muted">📎 ${this.escapeHtml(srcText)}</span>` : "";
    const altLine  = alt.length ? `<span class="line muted">🔁 Alternative: ${this.escapeHtml(alt.join(", "))}</span>` : "";

    const symLine  = sName ? `<span class="line">🩺 Simptom: <b>${this.escapeHtml(sName)}</b></span>` : "";
    const symDescLine = sName ? `<span class="line muted">📝 ${this.escapeHtml(sDesc || "Opis simptoma nije popunjen.")}</span>` : "";
    const mkbLine  = sName ? `<span class="line muted">🏷️ ${mkbMain}</span>` : "";

    if (this.ui.pStatus) {
      this.ui.pStatus.innerHTML =
        `<span class="line">🎵 Sada: <b>${hz} Hz</b>${carrierNote} <small>(${idx}/${total})</small></span>` +
        `${descLine}${srcLine}` +
        `<span class="line">${nextLine}</span>` +
        `${altLine}` +
        `${symLine}${symDescLine}${mkbLine}` +
        `${mkbLink}`;
    }

    // Keep Now-Playing list in sync while running
    this.renderNowPlayingList(stats);
  }


  onAudioTick(stats) {
    this._lastStats = stats;
    const seq = (this.audio && this.audio.currentSequence) ? this.audio.currentSequence : [];
    const curObj = seq && seq.length ? (seq[Number(stats?.currentIndex||0)] || {}) : {};
    this._updateMediaSessionMetadata(curObj, stats);

    const hasPer = !!stats?.hasPerFreqDurations;
    const totalTrack = hasPer ? (Number(stats.totalTrackSec)||0) : (Number(stats.totalItems)||0) * (Number(stats.durationPerFreq)||0);

    // robustno: ako elapsedInFreq ne "radi" u nekim browserima / audio režimima,
    // izračunaj ga iz ukupnog vremena
    const per = Number(stats.durationPerFreq) || 0;
    const curDur = hasPer ? (Number(stats.durationCurrentSec)||0) : per;

    const elapsedTrack = hasPer ? (Number(stats.elapsedTrackSec)||0) : (Number(stats.currentIndex)||0) * per + (Number(stats.elapsedInFreq)||0);

    let elapsedInFreq = Number(stats.elapsedInFreq);
    if (!Number.isFinite(elapsedInFreq) || elapsedInFreq < 0) elapsedInFreq = 0;
    if (!elapsedInFreq && !hasPer) {
      const approx = elapsedTrack - (Number(stats.currentIndex) || 0) * per;
      elapsedInFreq = Math.max(0, Math.min(per, approx));
    }
    if (hasPer) {
      // clamp to current duration
      elapsedInFreq = Math.max(0, Math.min(curDur, elapsedInFreq));
    }

// UI: levo = u frekvenciji, sredina = ukupno, desno = ukupno trajanje
    if (this.ui.pTimerNow) this.ui.pTimerNow.innerText = this.formatTime(elapsedInFreq);
    if (this.ui.pTimerElapsed) this.ui.pTimerElapsed.innerText = this.formatTime(elapsedTrack);
    if (this.ui.pTimerTotal) this.ui.pTimerTotal.innerText = this.formatTime(totalTrack);

    if (this.isPlaylistActive && this._protocolTimerEnabled) {
      const currentTotal = this.protocolBaseElapsedSec + elapsedTrack;
      if (this.ui.pProtocolTimer) {
        this.ui.pProtocolTimer.innerText = `UKUPNO: ${this.formatTime(currentTotal)} / ${this.formatTime(this.protocolTotalTimeSec)}`;
        this.ui.pProtocolTimer.style.display = 'block';
      }
    } else {
      if (this.ui.pProtocolTimer) this.ui.pProtocolTimer.style.display = 'none';
    }

    this.saveResumeState(false);
  }
  onAudioComplete() {
    this.log('PLAYER', 'Complete', this.selectedItem?.id || '');

    if (!this.isPlaylistActive) {
      this.stopPlayer(true);
      alert('Terapija završena.');
      return;
    }

    this._repeatRt = this._repeatRt || { baseProtocolSec: 0, queueCycle: 1, itemCycle: 1 };

    const scope = this.repeat?.scope || REPEAT_SCOPE_ITEM;
    const N = (this.repeat?.infinite) ? Infinity : Math.max(1, Number(this.repeat?.count) || 1);

    const idx = Number(this.currentPlaylistIndex) || 0;
    const isLastItem = (idx >= (this.playlist.length - 1));

    if (scope === REPEAT_SCOPE_ITEM) {
      const canRepeatItem = (this.repeat?.infinite) || (this._repeatRt.itemCycle < N);

      if (canRepeatItem) {
        this._repeatRt.itemCycle = (Number(this._repeatRt.itemCycle) || 1) + 1;
        try { this._renderRepeatStatus(); } catch (_) {}
        setTimeout(() => this.playPlaylistItem(idx), 250);
        return;
      }

      this._repeatRt.itemCycle = 1;
      try { this._renderRepeatStatus(); } catch (_) {}

      if (!isLastItem) {
        setTimeout(() => this.playPlaylistItem(idx + 1), 250);
        return;
      }

      this.stopPlayer(true);
      alert('Protokol završen!');
      return;
    }

    if (scope === REPEAT_SCOPE_QUEUE) {
      if (!isLastItem) {
        setTimeout(() => this.playPlaylistItem(idx + 1), 250);
        return;
      }

      const canRepeatQueue = (this.repeat?.infinite) || (this._repeatRt.queueCycle < N);
      if (canRepeatQueue) {
        this._repeatRt.queueCycle = (Number(this._repeatRt.queueCycle) || 1) + 1;
        try { this._renderRepeatStatus(); } catch (_) {}
        setTimeout(() => this.playPlaylistItem(0), 250);
        return;
      }

      this.stopPlayer(true);
      alert('Protokol završen!');
      return;
    }

    setTimeout(() => this.playPlaylistItem(idx + 1), 250);
  }


  togglePlayPause() {
    // iOS PRO (Rendered WAV): use HTMLAudioElement controls
    if (this._isIOS && this.isIosBgRenderedEnabled() && this._rendered && this._rendered.active) {
      const el = this._iosRenderedEl;
      if (!el) return;
      try {
        if (!el.paused && !el.ended) {
          el.pause();
          if (this.ui.btnPlayPause) this.ui.btnPlayPause.innerText = "▶";
          this.log("PLAYER", "Pause (iOS PRO Rendered)", this.selectedItem?.id || "");
          this.saveResumeState(false);
        } else {
          const p = el.play();
          if (p && typeof p.catch === "function") p.catch(() => {});
          if (this.ui.btnPlayPause) this.ui.btnPlayPause.innerText = "⏸";
          this.log("PLAYER", "Play (iOS PRO Rendered)", this.selectedItem?.id || "");
        }
      } catch(_) {}
      return;
    }

    if (this.audio.isPlaying) {
      const st = this.audio.pause();
      if (this.ui.btnPlayPause) this.ui.btnPlayPause.innerText = "▶";
      this._lastStats = {
        currentIndex: st.currentIndex,
        totalItems: st.totalItems,
        elapsedInFreq: st.elapsedInFreq,
        durationPerFreq: st.durationPerFreq
      };
      this.log("PLAYER", "Pause", `${this.selectedItem?.id||""} @${Math.round(st.elapsedInFreq)}s`);
      this._teardownPlaybackSession("pause");
      this.saveResumeState(false);
    } else {
      this._ensurePlaybackSession();
      this.audio.play();
      if (this.ui.btnPlayPause) this.ui.btnPlayPause.innerText = "⏸";
      this.log("PLAYER", "Play", this.selectedItem?.id || "");
    }
  }


  async stopPlayer(clearResume=false) {
    this._teardownPlaybackSession("stop");
    // iOS PRO: stop rendered track if active
    try { if (this._rendered && this._rendered.active) this._stopRenderedTrack(); } catch(_) {}
    this.log("PLAYER", "Stop", this.selectedItem?.id || "");
    await this.saveResumeState(true);
    this.audio.stop();
    if (this.ui.playerDock) { this.ui.playerDock.style.display = 'none'; this._syncDockPadding(true); }
    this.isPlaylistActive = false;
    if (this.ui.pStatus) this.ui.pStatus.innerText = "";
    if (clearResume) await this.db?.clearPlayerState?.();
    this.renderPlaylistUI();
    await this.renderResumeHint();
  }

  async saveResumeState(isStopEvent) {
    if (!this.db || !this.selectedItem || !this._lastStats) return;
    const payload = {
      activePlaylistIndex: this.currentPlaylistIndex,
      activePresetId: this.selectedItem.id,
      freqIndex: this._lastStats.currentIndex || 0,
      elapsedInFreqSec: this._lastStats.elapsedInFreq || 0,
      isPlaylistActive: !!this.isPlaylistActive,
      updatedAt: Date.now(),
      reason: isStopEvent ? "stop" : "tick"
    };
    try { await this.db.savePlayerState(payload); } catch(e) {}
  }

  async renderResumeHint() {
    const hint = document.getElementById("resume-hint");
    if (!hint || !this.db) return;
    const st = await this.db.getPlayerState();
    if (!st || !st.activePresetId) { hint.style.display="none"; return; }
    hint.style.display="block";
    hint.innerText = `RESUME dostupno: ${st.activePresetId} • frekvencija #${(st.freqIndex||0)+1} • ${Math.floor(st.elapsedInFreqSec||0)}s`;
  }

  async resumeLastSession() {
    const st = await this.db?.getPlayerState?.();
    if (!st) return alert("Nema sačuvanog stanja.");

    // Always refresh sources
    await this.loadPlaylistFromDB();
    await this.loadProtocolsFromDB();
    await this.loadAcupressureRegistry();

    const id = (st.activePresetId || "").toString();

    // 1) Resume user protocol
    if (id.startsWith("PROTO_")) {
      await this.playUserProtocolById(id, {
        freqIndex: Number(st.freqIndex)||0,
        elapsedInFreqSec: Number(st.elapsedInFreqSec)||0
      });
      this.log("PLAYER", "Resume Protocol", id);
      return;
    }

    // 2) Resume playlist protocol (queue of symptoms)
    if (st.isPlaylistActive) {
      if (!this.playlist.length) return alert("Lista je prazna.");
      const plIndex = Math.max(0, Number(st.activePlaylistIndex) || 0);
      this.isPlaylistActive = true;
      this.playPlaylistItem(plIndex, {
        freqIndex: Number(st.freqIndex)||0,
        elapsedInFreqSec: Number(st.elapsedInFreqSec)||0
      });
      this.log("PLAYER", "Resume Playlist", id);
      return;
    }

    // 3) Resume single symptom play-now
    const item = this.catalogItems.find(x => x.id === id);
    if (!item) return alert("Ne mogu da pronađem terapiju za RESUME.");

    const freqs = (item.frekvencije || []).filter(f => f.enabled !== false);
    const perFreqMin = Math.max(1, Number(item.trajanjePoFrekvencijiMin) || 5);
    const totalDurSec = freqs.length * perFreqMin * 60;

    this.selectedItem = item;
    this.isPlaylistActive = false;

    // iOS PRO (Rendered WAV): resume via rendered WAV track
    if (this._isIOS && this.isIosBgRenderedEnabled()) {
      const startIndex = Number(st.freqIndex)||0;
      const elapsedInFreq = Number(st.elapsedInFreqSec)||0;
      const perStepSec = (freqs.length ? (totalDurSec / freqs.length) : 0);
      const resumeTrackSec = Math.max(0, (startIndex * perStepSec) + elapsedInFreq);

      const r = await this._startRenderedTrack({
        sequence: freqs,
        durationsSec: null,
        totalSec: totalDurSec,
        resumeTrackSec,
        titleText: `[1/1] ${item.simptom}`,
        loopAll: false
      });
      if (r && r.fallback === false) {
        if (this.ui.btnPlayPause) this.ui.btnPlayPause.innerText = "⏸";
        this.log("PLAYER", "Resume Item (iOS PRO Rendered)", id);
        return;
      }
      // else: fallback to live WebAudio
    }

    this.audio.loadSequence(freqs, totalDurSec, Number(st.freqIndex)||0, Number(st.elapsedInFreqSec)||0);

    if (this.ui.playerDock) { this.ui.playerDock.style.display = 'block'; requestAnimationFrame(() => this._syncDockPadding(false)); }
    if (this.ui.nowPlayingPanel) this.ui.nowPlayingPanel.style.display = 'block';
    const btnNowList = document.getElementById('btn-nowlist');
    if (btnNowList) btnNowList.innerHTML = '▾ FREKVENCIJE';
    if (this.ui.pTitle) this.ui.pTitle.innerText = `[1/1] ${item.simptom}`;
    if (this.ui.pProtocolTimer) this.ui.pProtocolTimer.style.display = 'none';

    this._ensurePlaybackSession();
    this.audio.play();
    if (this.ui.btnPlayPause) this.ui.btnPlayPause.innerText = "⏸";
    this.log("PLAYER", "Resume Item", id);
  }
  /* ===================== v15.7.1.5 — Repeat helpers ===================== */

  _getPlaylistItemTotalSec(item) {
    const m = Number(item?.userTotalMin ?? 0) || 0;
    if (m > 0) return Math.max(1, m) * 60;
    const freqs = (item?.frekvencije || []).filter(f => f?.enabled !== false);
    const perFreqMin = Math.max(1, Number(item?.userPerFreqMin) || Number(item?.trajanjePoFrekvencijiMin) || 5);
    return Math.max(1, freqs.length * perFreqMin) * 60;
  }

  _computeBaseProtocolSec() {
    try {
      return (this.playlist || []).reduce((acc, it) => acc + this._getPlaylistItemTotalSec(it), 0);
    } catch (_) {
      return 0;
    }
  }

  _computeProtocolBaseElapsedSec(index) {
    const baseTotal = Number(this._repeatRt?.baseProtocolSec) || this._computeBaseProtocolSec();

    if (this.repeat?.scope === REPEAT_SCOPE_QUEUE) {
      const q = Math.max(1, Number(this._repeatRt?.queueCycle) || 1);
      let before = 0;
      for (let i = 0; i < index; i++) before += this._getPlaylistItemTotalSec(this.playlist[i]);
      return Math.max(0, (q - 1) * baseTotal + before);
    }

    // default: REPEAT_SCOPE_ITEM (A)
    let beforeItems = 0;
    for (let i = 0; i < index; i++) beforeItems += this._getPlaylistItemTotalSec(this.playlist[i]);
    const itemTotal = this._getPlaylistItemTotalSec(this.playlist[index]);
    const ic = Math.max(1, Number(this._repeatRt?.itemCycle) || 1);
    const N = (this.repeat?.infinite) ? Infinity : Math.max(1, Number(this.repeat?.count) || 1);
    const mult = Number.isFinite(N) ? N : 1;
    return Math.max(0, beforeItems * mult + itemTotal * (ic - 1));
  }  /* ===================== PROTOCOL ===================== */
  startProtocol() {
    if (!this.playlist.length) return;

    // Repeat settings (Playlist UI)
    try {
      const s = this._readRepeatSettings('playlist');
      this._applyRepeatSettings(s);
    } catch (_) {}

    this.isPlaylistActive = true;
    this._protocolTimerEnabled = true;
    this.currentPlaylistIndex = 0;

    // Repeat runtime
    this._repeatRt = this._repeatRt || { baseProtocolSec: 0, queueCycle: 1, itemCycle: 1 };
    this._repeatRt.queueCycle = 1;
    this._repeatRt.itemCycle = 1;
    this._repeatRt.baseProtocolSec = this._computeBaseProtocolSec();

    // Total protocol time (informational)
    if (this.repeat?.infinite) this.protocolTotalTimeSec = Infinity;
    else this.protocolTotalTimeSec = this._repeatRt.baseProtocolSec * Math.max(1, Number(this.repeat?.count) || 1);
    this.protocolBaseElapsedSec = 0;

    try { this._renderRepeatStatus(); } catch (_) {}

    // UX overlay
    try {
      this._showStartOverlay('⏳ PRIPREMAM…', 'Render/Start može potrajati (iPhone).');
      this._setStartButtonsEnabled(false);
    } catch (_) {}

    try {
      const p = this.playPlaylistItem(0);
      if (p && typeof p.catch === 'function') {
        p.catch(err => {
          console.warn('startProtocol failed', err);
          const msg = (err && (err.name || err.message)) ? `${err.name || ''} ${err.message || ''}`.trim() : 'unknown';
          this._hideStartOverlay?.();
          this._setStartButtonsEnabled?.(true);
          this.showToast(`⚠️ iPhone: start playback failed (${msg}). Pokušaj još jednom (tap ▶).`, {
            timeoutMs: 6500,
            action2Label: '▶',
            action2Onclick: 'window.app && window.app.startProtocol && window.app.startProtocol()'
          });
        });
      }
    } catch (err) {
      console.warn('startProtocol failed (sync)', err);
      const msg = (err && (err.name || err.message)) ? `${err.name || ''} ${err.message || ''}`.trim() : 'unknown';
      this._hideStartOverlay?.();
      this._setStartButtonsEnabled?.(true);
      this.showToast(`⚠️ iPhone: start playback failed (${msg}). Pokušaj još jednom (tap ▶).`, {
        timeoutMs: 6500,
        action2Label: '▶',
        action2Onclick: 'window.app && window.app.startProtocol && window.app.startProtocol()'
      });
    }

    this.log('PLAYER', 'Start Protocol', `${this.playlist.length} • repeat=${this.repeat?.scope||'item'} N=${this.repeat?.infinite?'∞':(this.repeat?.count||1)}`);
  }

  async playPlaylistItem(index, resume=null) {
    if (index >= this.playlist.length) {
      this.stopPlayer(true);
      alert('Protokol završen!');
      return;
    }

    const item = this.playlist[index];
    this.selectedItem = item;

    try {
      const r = this._getRecommendation(item);
      if (r?.segMin) this._renderSeg.segMin = Number(r.segMin) || DEFAULT_SEGMENT_MIN;
    } catch (_) {}

    try { this._renderRecommendationToPlayer(item); } catch(_) {}

    this.currentPlaylistIndex = index;

    this.protocolBaseElapsedSec = this._computeProtocolBaseElapsedSec(index);

    const freqs = (item.frekvencije || []).filter(f => f.enabled !== false);
    const perFreqMin = Math.max(1, Number(item.userPerFreqMin) || Number(item.trajanjePoFrekvencijiMin) || 5);
    const totalDurSec = freqs.length * perFreqMin * 60;

    const startIndex = resume?.freqIndex || 0;
    const elapsedInFreq = resume?.elapsedInFreqSec || 0;

    if (this._isIOS && this.isIosBgRenderedEnabled()) {
      const perStepSec = (freqs.length ? (totalDurSec / freqs.length) : 0);
      const resumeTrackSec = Math.max(0, (startIndex * perStepSec) + elapsedInFreq);
      const segMin = Number(this._renderSeg?.segMin) || DEFAULT_SEGMENT_MIN;

      const r = await this._startRenderedTrack({
        sequence: freqs,
        durationsSec: null,
        totalSec: totalDurSec,
        resumeTrackSec,
        titleText: `[${index+1}/${this.playlist.length}] ${item.simptom}`,
        loopAll: false,
        segmentMin: segMin
      });

      if (r && r.fallback === false) {
        if (this.ui.btnPlayPause) this.ui.btnPlayPause.innerText = '⏸';
        this.renderPlaylistUI();
        return;
      }
    }

    this.audio.loadSequence(freqs, totalDurSec, startIndex, elapsedInFreq);

    if (this.ui.playerDock) { this.ui.playerDock.style.display = 'block'; requestAnimationFrame(() => this._syncDockPadding(false)); }
    if (this.ui.nowPlayingPanel) this.ui.nowPlayingPanel.style.display = 'block';
    const btnNowList = document.getElementById('btn-nowlist');
    if (btnNowList) btnNowList.innerHTML = '▾ FREKVENCIJE';
    if (this.ui.pTitle) this.ui.pTitle.innerText = `[${index+1}/${this.playlist.length}] ${item.simptom}`;

    this._ensurePlaybackSession();
    this.audio.play();
    if (this.ui.btnPlayPause) this.ui.btnPlayPause.innerText = '⏸';

    try { this._hideStartOverlay(); this._setStartButtonsEnabled(true); } catch (_) {}

    this.renderPlaylistUI();
  }


  /* ===================== MODAL (details) ===================== */
  openModal(id) {
    this.currentModalId = id;
    const item = this.catalogItems.find(i => i.id === id);
    if (!item) return;

    this._modalItem = item;

    document.getElementById('m-title').innerText = item.simptom;

    // ⭐ Favorites status (async)
    this.refreshModalFavoriteUI();

    // ===== SUMMARY (OPIS + MKB-10) — uvek prikaži (sa placeholder-ima) =====
    const descBox = document.getElementById('m-desc-box');
    const descEl = document.getElementById('m-desc');
    const opis = (item.opis || item.description || item.desc || "").toString().trim();
    if (descEl) descEl.textContent = opis || "Opis nije popunjen (još).";
    if (descBox) descBox.style.display = 'block';

    const mkbBox = document.getElementById('m-mkb-box');
    const mkbEl = document.getElementById('m-mkb');
    const mkbHtml = this.formatMKB10Html(item.mkb10, { includeLink: true, showEmpty: true });
    if (mkbEl) mkbEl.innerHTML = mkbHtml;
    if (mkbBox) mkbBox.style.display = 'block';


// init duration slider
    const slider = document.getElementById('m-slider');
    const perMinInit = Math.max(1, Number(item.trajanjePoFrekvencijiMin) || 5);
    if (slider) slider.value = String(perMinInit);
    const durLbl = document.getElementById('m-dur-lbl');
    if (durLbl) durLbl.innerText = `${perMinInit} min`;

    // v15.7.1.5 — Preporuka block + default loop controls
    try { this._renderRecommendationToModal(item); } catch(_) {}
    try {
      const r = this._getRecommendation(item);
      const sel = document.getElementById("m-repeat-count");
      if (sel) sel.value = String(Math.max(1, r.loopN || 1));
      const cb = document.getElementById("m-repeat-infinite");
      if (cb) cb.checked = false;

      // scope default (A) — item
      const ra = document.querySelector('input[name="m-repeat-scope"][value="item"]');
      if (ra) ra.checked = true;
    } catch(_) {}

    // show frequencies list with svrha/izvor
    const freqsAll = (item.frekvencije || []);
    const freqs = freqsAll.filter(f=>f.enabled!==false);
    const perMin = Math.max(1, Number(item.trajanjePoFrekvencijiMin)||5);
    const freqBox = document.getElementById('m-freqs');
    if (freqBox) {
      const rows = freqsAll.map((f, i) => `
        <div style="display:flex; gap:10px; padding:8px 0; border-bottom:1px solid #eee;">
          <div style="min-width:140px; font-weight:900;"><input class="freq-toggle" type="checkbox" ${f.enabled === false ? "" : "checked"} onchange="window.app.setModalFreqEnabled(${i}, this.checked)" style="margin-right:10px;">${(f.value ?? f.hz ?? 0)} Hz</div>
          <div style="flex:1;">
            <div style="font-size:0.9rem;"><b>#${i+1}</b> • ${this.escapeHtml(((f.svrha || f.funkcija || f.desc || f.naziv || "—").toString()))}</div>
            <div style="font-size:0.8rem; color:#666;">Izvor: ${this.escapeHtml(this._srcToText(f.izvor) || "—")}</div>
          </div>
          <div style="min-width:70px; text-align:right; font-weight:800; color:#2c3e50;">${perMin} min</div>
        </div>
      `).join("");
      const totalMin = freqs.length * perMin;
      freqBox.innerHTML = `
        <div style="font-weight:900; margin-top:6px;">Frekvencije (ukupno: ${freqs.length}) • Procena: ${totalMin} min</div>
        <div class="freq-listwrap">${rows || "<i>Nema frekvencija</i>"}</div>
      `;
    }

// holistic (supports legacy + STL-normalized)
const h = item.holisticki || item.holistika || {};
let html = "";

const addBox = (label, color, body, source=null) => {
  if (!body) return;
  html += `<div class="holistic-box" style="border-left:4px solid ${color}">
    <small style="color:${color}; font-weight:bold;">${label}</small><br>
    ${body}
    ${source ? `<div style="margin-top:6px; font-size:0.75rem; color:#666;">Izvor: ${source}</div>` : ""}
  </div>`;
};

addBox("PSIHOSOMATIKA – UZROK", "#8e44ad", h.psihosomatika?.uzrok || "");
addBox("PSIHOSOMATIKA – LEK", "#8e44ad", h.psihosomatika?.lek || "");

addBox("AFIRMACIJA", "#16a085",
  h.afirmacija?.tekst ? `${h.afirmacija.tekst}${h.afirmacija.autor ? `<div style="margin-top:6px;"><b>Autor:</b> ${h.afirmacija.autor}</div>` : ""}` : "",
  h.afirmacija?.izvor || ""
);

// molitva / duhovnost
addBox("MOLITVA", "#f39c12", h.molitva?.tekst || h.duhovnost?.tekst || "", h.molitva?.izvor || h.duhovnost?.izvor || "");

// narodni lek
addBox("NARODNI LEK", "#27ae60", h.narodni_lek?.opis || h.saveti?.narodno || "");

document.getElementById('m-holistic').innerHTML = html;

// akupresura
this.renderAcupressureInModal(item);

    // v15.3 — advanced JSON / local override
    this.renderModalAdvanced(item);

    this.updateModalDuration();

    document.getElementById('modal').style.display = 'flex';
    this.log("UI", "Open Modal", id);
  }

updateModalDuration() {
  const slider = document.getElementById('m-slider');
  const perMin = Math.max(1, Number(slider?.value || "5"));
  const lbl = document.getElementById('m-dur-lbl');
  if (lbl) lbl.innerText = `${perMin} min`;

  // Store for modal freq toggles
  if (this._modalItem) this._modalItem.freq_duration_min = perMin;

  // Live re-render frequency table so user immediately sees new estimate
  const item = this._modalItem || this.catalogItems.find(i => i.id === this.currentModalId);
  if (!item) return;

  const freqsAll = (item.frekvencije || []);
  const freqs = freqsAll.filter(f => f.enabled !== false);
  const freqBox = document.getElementById('m-freqs');
  if (!freqBox) return;

  const rows = freqsAll.map((f, i) => `
    <div style="display:flex; gap:10px; padding:8px 0; border-bottom:1px solid #eee;">
      <div style="min-width:140px; font-weight:900;"><input class="freq-toggle" type="checkbox" ${f.enabled === false ? "" : "checked"} onchange="window.app.setModalFreqEnabled(${i}, this.checked)" style="margin-right:10px;">${(f.value ?? f.hz ?? 0)} Hz</div>
      <div style="flex:1;">
        <div style="font-size:0.9rem;"><b>#${i+1}</b> • ${this.escapeHtml(((f.svrha || f.funkcija || f.desc || f.naziv || "—").toString()))}</div>
        <div style="font-size:0.8rem; color:#666;">Izvor: ${this.escapeHtml(this._srcToText(f.izvor) || "—")}</div>
      </div>
      <div style="min-width:70px; text-align:right; font-weight:800; color:#2c3e50;">${perMin} min</div>
    </div>
  `).join("");

  const totalMin = freqs.length * perMin;
  freqBox.innerHTML = `
    <div style="font-weight:900; margin-top:6px;">Frekvencije (ukupno: ${freqs.length}) • Procena: ${totalMin} min</div>
    <div class="freq-listwrap">${rows || "<i>Nema frekvencija</i>"}</div>
  `;

  // Update advanced proto line if present
  const proto = document.getElementById('m-proto');
  if (proto) {
    const enabledCount = freqs.length;
    const loops = Math.max(1, Number(item.freq_loops) || 1);
    const estMin = enabledCount * perMin;
    proto.textContent = `${enabledCount} frekv. • ${perMin} min x ${loops} = ~${estMin * loops} min`;
  }
}

_extractAcupPoints(item){
  const a = item?.akupresura;
  if (!a) return [];
  if (Array.isArray(a)) return a;
  if (Array.isArray(a.points)) return a.points;
  if (Array.isArray(a.tacke)) return a.tacke;
  return [];
}

renderAcupressureInModal(item){
  const box = document.getElementById('m-acupressure');
  if (!box) return;

  const pts = this._extractAcupPoints(item);
  if (!pts.length){
    box.innerHTML = `<div class="muted" style="color:#777; font-style:italic;">Nema akupresure za ovaj simptom (još). 🙂</div>`;
    return;
  }

  const regPoints = this.acupressureRegistry?.points || {};

  const cards = pts.map((p, i) => {
    const code = (p.tacka || p.tačka || p.code || "").toString().trim();
    const name = (p.naziv || p.name || "").toString().trim();
    const loc  = (p.lokacija || "").toString().trim();
    const how  = (p.uputstvo || p.uputstva || "").toString().trim();
    const src  = (p.izvor?.url || p.izvor || "").toString().trim();

    const reg = code ? regPoints[code] : null;
    const img = (p.slika || reg?.default || (Array.isArray(reg?.files) && reg.files[0]) || "").toString().trim();
    const hasImg = !!img;

    return `
      <div class="acup-card">
        <div class="acup-head">
          <div class="acup-code">${code || "TAČKA"}</div>
          <div class="acup-name">${name || ""}</div>
        </div>
        ${loc ? `<div class="acup-loc">📍 ${loc}</div>` : ""}
        ${how ? `<div class="acup-how">👉 ${how}</div>` : ""}
        ${src ? `<div class="muted" style="margin-top:6px; font-size:0.8rem; color:#666;">Izvor: ${src}</div>` : ""}
        <div class="acup-actions">
          <button class="acup-btn" onclick="openAcupressureViewer('${item.id}', ${i})">${hasImg ? "👁 Prikaži" : "👁 Prikaži (bez slike)"}</button>
        </div>
      </div>`;
  }).join("");

  box.innerHTML = `<div class="acup-grid">${cards}</div>`;
}

openAcupressureViewer(itemId, idx){
  const modal = document.getElementById('acupressure-modal');
  if (!modal) return;

  const item = this.catalogItems.find(i => i.id === itemId);
  if (!item) return;

  const pts = this._extractAcupPoints(item);
  const p = pts[Number(idx)] || null;
  if (!p) return;

  const code = (p.tacka || p.tačka || p.code || "").toString().trim();
  const name = (p.naziv || p.name || "").toString().trim();
  const loc  = (p.lokacija || "").toString().trim();
  const how  = (p.uputstvo || p.uputstva || "").toString().trim();
  const src  = (p.izvor?.url || p.izvor || "").toString().trim();

  // Title
  const t = document.getElementById('acup-title');
  if (t) t.innerText = `${code || "Akupresura"}${name ? " — " + name : ""}`;

  // Image resolve: point.slika > registry.points[code].default > first file
  const reg = (code && this.acupressureRegistry?.points) ? this.acupressureRegistry.points[code] : null;
  const imgPath = (p.slika || reg?.default || (Array.isArray(reg?.files) && reg.files[0]) || "").toString().trim();

  const img = document.getElementById('acup-img');
  const noimg = document.getElementById('acup-noimg');

  if (imgPath) {
    if (img) { img.src = imgPath; img.style.display = "block"; }
    if (noimg) noimg.style.display = "none";
  } else {
    if (img) { img.removeAttribute("src"); img.style.display = "none"; }
    if (noimg) noimg.style.display = "block";
  }

  // Marker (0..1 coords)
  const marker = document.getElementById('acup-marker');
  const mx = Number(p.marker?.x);
  const my = Number(p.marker?.y);
  if (marker && Number.isFinite(mx) && Number.isFinite(my)) {
    marker.style.display = "block";
    marker.style.left = `${Math.max(0, Math.min(1, mx)) * 100}%`;
    marker.style.top  = `${Math.max(0, Math.min(1, my)) * 100}%`;
  } else if (marker) {
    marker.style.display = "none";
  }

  // Text
  const elLoc = document.getElementById('acup-loc');
  const elHow = document.getElementById('acup-how');
  const elSrc = document.getElementById('acup-src');

  if (elLoc) elLoc.innerText = loc ? `📍 ${loc}` : "";
  if (elHow) elHow.innerText = how || "";
  if (elSrc) elSrc.innerText = src ? `Izvor: ${src}` : "";

  modal.style.display = "flex";
  this.log("UI", "Acupressure Viewer Open", `${itemId}:${idx}`);
}

closeAcupressureViewer(){
  const modal = document.getElementById('acupressure-modal');
  if (modal) modal.style.display = "none";
}


  closeModal() {
    document.getElementById('modal').style.display = 'none';
    this.log("UI", "Close Modal", this.currentModalId||"");
  }
  playFromModal() {
    const item = this.catalogItems.find(i => i.id === this.currentModalId);
    if (!item) return;

    try {
      const s = this._readRepeatSettings('modal');
      if (s && s.scope === REPEAT_SCOPE_QUEUE) s.scope = REPEAT_SCOPE_ITEM;
      this._applyRepeatSettings(s);
    } catch (_) {}

    const perFreqMin = Number(document.getElementById('m-slider')?.value || '5');
    const freqsAll = (item.frekvencije || []);
    const freqs = freqsAll.filter(f => f.enabled !== false);
    const totalMin = Math.max(1, freqs.length * perFreqMin);

    this.isPlaylistActive = true;
    this._protocolTimerEnabled = false;
    this.currentPlaylistIndex = 0;

    this.playlist = [{
      ...item,
      uid: Date.now(),
      userPerFreqMin: perFreqMin,
      userTotalMin: totalMin
    }];
    this.savePlaylistToDB();

    this._repeatRt = this._repeatRt || { baseProtocolSec: 0, queueCycle: 1, itemCycle: 1 };
    this._repeatRt.queueCycle = 1;
    this._repeatRt.itemCycle = 1;
    this._repeatRt.baseProtocolSec = this._computeBaseProtocolSec();

    if (this.repeat?.infinite) this.protocolTotalTimeSec = Infinity;
    else this.protocolTotalTimeSec = this._repeatRt.baseProtocolSec * Math.max(1, Number(this.repeat?.count) || 1);
    this.protocolBaseElapsedSec = 0;

    try { this._renderRepeatStatus(); } catch (_) {}

    try {
      this._showStartOverlay('⏳ PRIPREMAM…', 'Render/Start može potrajati (iPhone).');
      this._setStartButtonsEnabled(false);
    } catch (_) {}

    try {
      const p = this.playPlaylistItem(0);
      if (p && typeof p.catch === 'function') {
        p.catch(err => {
          console.error('playFromModal error', err);
          const msg = (err && (err.name || err.message)) ? `${err.name || ''} ${err.message || ''}`.trim() : 'unknown';
          this._hideStartOverlay?.();
          this._setStartButtonsEnabled?.(true);
          this.showToast(`⚠️ iPhone: start playback failed (${msg}). Pokušaj još jednom (tap ▶).`, {
            timeoutMs: 6500,
            action2Label: '▶',
            action2Onclick: 'window.app && window.app.playPlaylistItem && window.app.playPlaylistItem(0)'
          });
        });
      }
    } catch (err) {
      console.error('playFromModal error (sync)', err);
      const msg = (err && (err.name || err.message)) ? `${err.name || ''} ${err.message || ''}`.trim() : 'unknown';
      this._hideStartOverlay?.();
      this._setStartButtonsEnabled?.(true);
      this.showToast(`⚠️ iPhone: start playback failed (${msg}). Pokušaj još jednom (tap ▶).`, {
        timeoutMs: 6500,
        action2Label: '▶',
        action2Onclick: 'window.app && window.app.playPlaylistItem && window.app.playPlaylistItem(0)'
      });
    }

    if (this.ui.pProtocolTimer) this.ui.pProtocolTimer.style.display = 'none';

    this.closeModal();
    this.nav('playlist');

    try {
      requestAnimationFrame(() => {
        const dock = this.ui.playerDock;
        if (dock) dock.scrollIntoView({ block: 'end' });
      });
    } catch (_) {}
  }

  async addToPlaylistFromModal() {
    const item = this.catalogItems.find(i => i.id === this.currentModalId);
    if (!item) return;

    const perFreqMin = Number(document.getElementById('m-slider')?.value || "5");
    const freqsAll = (item.frekvencije || []);
    const freqs = freqsAll.filter(f=>f.enabled!==false);
    const totalMin = Math.max(1, freqs.length * perFreqMin);

    this.playlist.push({
      ...item,
      uid: Date.now(),
      userPerFreqMin: perFreqMin,
      userTotalMin: totalMin
    });

    await this.savePlaylistToDB();
    this.renderPlaylistUI();
    this.closeModal();
    this.log("USER", "Add To Playlist", item.id);
    this.showToast('✅ Dodato u listu.', {
      actionLabel: '🎵 Otvori listu',
      actionNav: 'playlist',
      action2Label: '▶ Pusti odmah',
      action2Onclick: `window.app && window.app.playItemNow && window.app.playItemNow('${item.id}')`
    });
  }

  async quickAddToPlaylist(id) {
    const item = this.catalogItems.find(i => i.id === id);
    if (!item) return;

    const perFreqMin = Math.max(1, Number(item.trajanjePoFrekvencijiMin)||5);
    const freqsAll = (item.frekvencije||[]);
    const freqs = freqsAll.filter(f=>f.enabled!==false);

    const totalMin = Math.max(1, freqs.length * perFreqMin);

    this.playlist.push({ ...item, uid: Date.now(), userPerFreqMin: perFreqMin, userTotalMin: totalMin });
    await this.savePlaylistToDB();
    this.renderPlaylistUI();
    this.log("USER", "Quick Add Playlist", item.id);

    this.showToast('✅ Dodato u listu.', {
      actionLabel: '🎵 Otvori listu',
      actionNav: 'playlist',
      action2Label: '▶ Pusti odmah',
      action2Onclick: `window.app && window.app.playItemNow && window.app.playItemNow('${id}')`
    });
  }

  // v15.4.4 — Play selected symptom immediately (without destroying user's playlist)
  async playItemNow(id) {
    const item = this.catalogItems.find(i => i.id === id);
    if (!item) return;

    const freqs = (item.frekvencije || []).filter(f => f.enabled !== false);
    const perFreqMin = Math.max(1, Number(item.trajanjePoFrekvencijiMin) || 5);
    const totalDurSec = freqs.length * perFreqMin * 60;

    this.selectedItem = item;
    this.isPlaylistActive = false;

    // iOS PRO (Rendered WAV): render protocol to WAV-in-RAM and play via <audio> (better chance to continue in background)
    if (this._isIOS && this.isIosBgRenderedEnabled()) {
      const r = await this._startRenderedTrack({
        sequence: freqs,
        durationsSec: null,
        totalSec: totalDurSec,
        resumeTrackSec: 0,
        titleText: `[1/1] ${item.simptom}`,
        loopAll: false
      });
      if (r && r.fallback === false) {
        if (this.ui.btnPlayPause) this.ui.btnPlayPause.innerText = "⏸";
        this.log("PLAYER", "Play Now (iOS PRO Rendered)", item.id);
        return;
      }
      // else: fallback to live WebAudio
    }

    this.audio.loadSequence(freqs, totalDurSec, 0, 0);

    if (this.ui.playerDock) { this.ui.playerDock.style.display = 'block'; requestAnimationFrame(() => this._syncDockPadding(false)); }
    if (this.ui.nowPlayingPanel) this.ui.nowPlayingPanel.style.display = 'block';
    const btnNowList = document.getElementById('btn-nowlist');
    if (btnNowList) btnNowList.innerHTML = '▾ FREKVENCIJE';
    if (this.ui.pTitle) this.ui.pTitle.innerText = `[1/1] ${item.simptom}`;
    if (this.ui.pProtocolTimer) this.ui.pProtocolTimer.style.display = 'none';

    this._ensurePlaybackSession();
    this.audio.play();
    if (this.ui.btnPlayPause) this.ui.btnPlayPause.innerText = "⏸";
    this.log("PLAYER", "Play Now", item.id);
  }

  renderPlaylistUI() {
    const container = document.getElementById('playlist-container');
    if (!container) return;

    if (!this.playlist.length) {
      container.innerHTML = "<p style='text-align:center; padding:20px; color:#999'>Lista je prazna.</p>";
      const a = document.getElementById('pl-actions');
      if (a) a.style.display='none';
      const b = document.getElementById('badge-pl');
      if (b) b.style.display='none';
      return;
    }

    const a = document.getElementById('pl-actions');
    if (a) a.style.display='block';
    const b = document.getElementById('badge-pl');
    if (b) { b.innerText = this.playlist.length; b.style.display='inline-block'; }

    const totalMin = this.playlist.reduce((acc, it)=> acc + (Number(it.userTotalMin)||0), 0);
    const td = document.getElementById('pl-total-duration');
    if (td) td.innerText = `${totalMin} min`;

    container.innerHTML = this.playlist.map((item, index) => {
      const active = (this.isPlaylistActive && this.currentPlaylistIndex===index) ? "active" : "";
      const mkbCode = this.getMKB10Code(item.mkb10);
      const mkbDesc = this.getMKB10Desc(item.mkb10);
      const mkbBadge = mkbCode ? `<span class="mkb-badge" style="background:#eef3ff; font-size:0.75rem; padding:2px 6px; border-radius:7px; margin-left:6px;">${this.escapeHtml(mkbCode)}</span>` : "";
      const mkbLine = (mkbCode || mkbDesc)
        ? `<small style="color:#777;">🏷️ ${this.escapeHtml(mkbCode || "")}${(mkbCode && mkbDesc) ? " — " : ""}${this.escapeHtml((mkbDesc || "").slice(0,80))}</small>`
        : `<small style="color:#999;">🏷️ MKB-10: nije popunjeno</small>`;

      return `
        <div class="playlist-item ${active}">
          <div style="flex:1">
            <strong style="display:block;">${index+1}. ${this.escapeHtml(item.simptom)} ${mkbBadge}</strong>
            <small style="color:#777;">${item.userPerFreqMin||5} min/freq • ukupno: ${item.userTotalMin||0} min</small>
            ${mkbLine}
          </div>
          <button onclick="app.removeFromPlaylist('${item.uid}')" style="background:none; border:none; color:#C0392B; font-weight:bold; font-size:1.2rem;">✕</button>
        </div>
      `;
    }).join("");
  }


  async removeFromPlaylist(uid) {
    this.playlist = this.playlist.filter(i => i.uid != uid);
    await this.savePlaylistToDB();
    this.renderPlaylistUI();
    this.log("USER", "Remove From Playlist", String(uid));
  }

  async clearPlaylist() {
    if (!confirm("Obrisati listu?")) return;
    this.playlist = [];
    await this.savePlaylistToDB();
    this.renderPlaylistUI();
    this.log("USER", "Clear Playlist", "");
  }


  /* ===================== MY PROTOCOLS (frequency sequences) ===================== */

  async loadProtocolsFromDB() {
    if (!this.db || !this.db.getProtocols) { this.protocols = []; return; }
    try {
      this.protocols = await this.db.getProtocols();
    } catch(e) {
      this.protocols = [];
    }
  }

  _newProtoId() {
    const r = Math.random().toString(36).slice(2,8);
    return `PROTO_${Date.now()}_${r}`;
  }

  _clone(obj) {
    try { return JSON.parse(JSON.stringify(obj)); } catch(e) { return obj; }
  }

  _expandSymptomToSteps(item, perFreqMinOverride=null, metaLabel="") {
    if (!item) return [];
    const freqs = (item.frekvencije || []).filter(f => f && f.enabled !== false);
    const perMin = Math.max(0.5, Number(perFreqMinOverride ?? item.userPerFreqMin ?? item.trajanjePoFrekvencijiMin ?? 5) || 5);
    const steps = [];
    for (const f of freqs) {
      const hz = Number(f.value ?? f.hz) || 0;
      if (!hz) continue;
      const step = this._clone(f);
      step.value = hz; // audio engine uses .value
      step.hz = hz;
      step._from = { symptomId: item.id, symptom: item.simptom };
      if (metaLabel) step.note = metaLabel;
      // keep catalog descriptive fields; ensure string safety
      steps.push({ freq: step, minutes: perMin });
    }
    return steps;
  }

  _stepsToSequence(steps) {
    const seq = [];
    const durs = [];
    for (const s of (Array.isArray(steps) ? steps : [])) {
      const f = (s && typeof s === "object") ? (s.freq || s) : null;
      if (!f) continue;
      const hz = Number(f.value ?? f.hz) || 0;
      if (!hz) continue;

      const obj = this._clone(f);
      obj.value = hz;
      obj.hz = hz;

      // Make custom label visible in player
      if (!obj.funkcija && !obj.svrha && obj.note) obj.funkcija = obj.note;

      seq.push(obj);
      const min = Math.max(0, Number(s.minutes ?? s.min ?? s.trajanje_min ?? 0) || 0);
      durs.push(Math.max(0, min * 60));
    }
    return { seq, durs, totalSec: durs.reduce((a,b)=>a+b,0) };
  }


_sanitizeLoopCount(n) {
  const v = Math.floor(Number(n) || 1);
  if (!Number.isFinite(v)) return 1;
  return Math.max(1, Math.min(20, v));
}

_repeatSteps(steps, loops) {
  const L = this._sanitizeLoopCount(loops);
  if (L <= 1) return Array.isArray(steps) ? steps : [];
  const src = Array.isArray(steps) ? steps : [];
  const out = [];
  for (let i=0;i<L;i++) {
    for (const s of src) out.push(this._clone(s));
  }
  return out;
}

  renderProtocolsUI() {
    const listEl = this.ui.protocolsList || document.getElementById("protocols-list");
    const editorEl = this.ui.protocolEditor || document.getElementById("protocol-editor");
    if (!listEl || !editorEl) return;

    // Render list
    const protos = Array.isArray(this.protocols) ? this.protocols : [];
    if (!protos.length) {
      listEl.innerHTML = `<p style="text-align:center; padding:20px; color:#999">Nema sačuvanih protokola.\n<br>Napravite novi protokol ili generišite iz Favorita / Liste.</p>`;
    } else {
      listEl.innerHTML = protos.map(p => {
        const name = (p.name || p.naziv || "Protokol").toString();
        const steps = Array.isArray(p.steps) ? p.steps : [];
        const baseMin = steps.reduce((acc,s)=> acc + (Number(s.minutes||0) || 0), 0);
        const loops = this._sanitizeLoopCount(p.loopCount ?? p.loops ?? 1);
        const totalMin = baseMin * loops;
        const updated = p.updatedAt ? new Date(p.updatedAt).toLocaleString() : "";
        return `
          <div class="proto-card">
            <div class="proto-head">
              <div style="flex:1;">
                <div class="proto-title">🧩 ${this.escapeHtml(name)}</div>
                <div class="proto-meta">Koraka: <b>${steps.length}</b> • Trajanje: <b>${Math.round(totalMin*10)/10} min</b>${loops>1 ? ` • Loop: <b>${loops}×</b>` : ''}${updated ? ` • <span class="muted">${this.escapeHtml(updated)}</span>` : ""}</div>
              </div>
              <div class="proto-actions">
                <button class="btn-mini" onclick="window.app.playUserProtocolById('${this.escapeAttr(p.id)}')">▶ Pusti</button>
                <button class="btn-mini" onclick="window.app.openProtocolEditor('${this.escapeAttr(p.id)}')">✏️ Izmeni</button>
                <button class="btn-mini" onclick="window.app.exportSingleProtocol('${this.escapeAttr(p.id)}')">⬆ Export</button>
                <button class="btn-mini danger" onclick="window.app.deleteProtocolById('${this.escapeAttr(p.id)}')">🗑</button>
              </div>
            </div>
          </div>
        `;
      }).join("");
    }

    // Render editor
    if (!this._protoEdit) {
      editorEl.innerHTML = "";
      return;
    }

    const p = this._protoEdit;
    const name = (p.name || "Novi protokol").toString();
    const steps = Array.isArray(p.steps) ? p.steps : [];
    const baseMin = steps.reduce((acc,s)=> acc + (Number(s.minutes||0) || 0), 0);
    const loops = this._sanitizeLoopCount(p.loopCount ?? p.loops ?? 1);
    const totalMin = baseMin * loops;

    const stepRows = steps.map((s, idx) => {
      const f = s.freq || {};
      const hz = Number(f.value ?? f.hz) || 0;
      const label = (f.funkcija || f.svrha || f.desc || f.note || f.naziv || "").toString();
      const min = Math.max(0, Number(s.minutes || 0) || 0);
      return `
        <div class="proto-step-row">
          <div class="proto-step-main">
            <div><b>${hz} Hz</b> ${label ? `<span class="muted">— ${this.escapeHtml(label)}</span>` : ""}</div>
            <div class="muted" style="font-size:0.82rem;">⏱ ${min} min</div>
          </div>
          <div class="proto-step-actions">
            <button class="btn-mini" onclick="window.app.protoMoveStep(${idx}, -1)">↑</button>
            <button class="btn-mini" onclick="window.app.protoMoveStep(${idx}, 1)">↓</button>
            <button class="btn-mini danger" onclick="window.app.protoRemoveStep(${idx})">✖</button>
          </div>
        </div>
      `;
    }).join("");

    editorEl.innerHTML = `
      <div id="protocol-editor-box" class="proto-editor">
        <div style="display:flex; gap:10px; align-items:center; justify-content:space-between; flex-wrap:wrap;">
          <h3 style="margin:0;">🧩 Uređivanje protokola</h3>
          <div style="display:flex; gap:8px; flex-wrap:wrap;">
            <button class="btn-mini" onclick="window.app.protoAppendFromFavorites()">⭐ Dodaj iz Favorita</button>
            <button class="btn-mini" onclick="window.app.protoAppendFromQueue()">🎵 Dodaj iz Liste</button>
            <button class="btn-mini" onclick="window.app.protoSave()">💾 Sačuvaj</button>
            <button class="btn-mini danger" onclick="window.app.protoCancel()">✖ Zatvori</button>
          </div>
        </div>

        <div style="margin-top:10px; display:flex; gap:10px; flex-wrap:wrap; align-items:center;">
          <label style="flex:1; min-width:200px;">
            <div class="muted" style="font-size:0.85rem; margin-bottom:4px;">Naziv</div>
            <input class="input" value="${this.escapeAttr(name)}" oninput="window.app.protoSetName(this.value)" placeholder="Naziv protokola">
          
          </label>

          <div style="min-width:220px;">
            <div class="muted" style="font-size:0.85rem; margin-bottom:4px;">Loop protokola</div>
            <div style="display:flex; gap:8px; align-items:center; flex-wrap:wrap;">
              <label style="display:flex; gap:6px; align-items:center; user-select:none;">
                <input type="checkbox" ${loops>1 ? "checked" : ""} onchange="window.app.protoSetLoopEnabled(this.checked)">
                <span>Uključi</span>
              </label>
              <input class="input" type="number" min="1" max="20" step="1" value="${loops}" oninput="window.app.protoSetLoopCount(this.value)" style="width:92px;" ${loops>1 ? "" : "disabled"}>
              <span class="muted" style="font-size:0.85rem;">× (1–20)</span>
            </div>
          </div>

          <div style="min-width:180px; text-align:right;">

            <div class="muted" style="font-size:0.85rem;">Ukupno</div>
            <div style="font-weight:900;">${Math.round(totalMin*10)/10} min</div>
          </div>
        </div>

        <div style="margin-top:12px;" class="proto-add-grid">
          <div class="proto-add-card">
            <div style="font-weight:900; margin-bottom:6px;">➕ Dodaj ručno</div>
            <div style="display:flex; gap:8px; flex-wrap:wrap;">
              <input id="proto_hz" class="input" type="number" step="0.01" placeholder="Hz (npr 7.83)" style="width:140px;">
              <input id="proto_min" class="input" type="number" step="0.5" placeholder="min (npr 5)" style="width:120px;">
              <input id="proto_lbl" class="input" type="text" placeholder="opis (opciono)" style="flex:1; min-width:180px;">
              <button class="btn-mini" onclick="window.app.protoAddManual()">Dodaj</button>
            </div>
          </div>

          <div class="proto-add-card">
            <div style="font-weight:900; margin-bottom:6px;">🔎 Dodaj iz kataloga</div>
            <div style="display:flex; gap:8px; flex-wrap:wrap; align-items:center;">
              <input id="proto_search" class="input" type="text" placeholder="pretraga (simptom ili Hz)" style="flex:1; min-width:180px;">
              <button class="btn-mini" onclick="window.app.protoSearch()">Traži</button>
            </div>
            <div id="proto_search_results" style="margin-top:8px;"></div>
          </div>
        </div>

        <div style="margin-top:12px;">
          <div style="font-weight:900; margin-bottom:6px;">Koraci</div>
          <div class="proto-steps">${stepRows || "<div class='muted'>Nema koraka (još).</div>"}</div>
        </div>
      </div>
    `;
  }

  openProtocolEditor(id=null) {
    if (!id) {
      this._protoEdit = { id: this._newProtoId(), name: "Novi protokol", loopCount: 1, steps: [] };
      this.nav("protocols");
      this.renderProtocolsUI();
      return;
    }
    const p = (this.protocols || []).find(x => x.id === id);
    if (!p) return;
    this._protoEdit = this._clone(p);
    if (!Array.isArray(this._protoEdit.steps)) this._protoEdit.steps = [];
    if (!this._protoEdit.loopCount) this._protoEdit.loopCount = 1;
    this.nav("protocols");
    this.renderProtocolsUI();
  }

  protoCancel() {
    this._protoEdit = null;
    this.renderProtocolsUI();
  }

  protoSetName(v) {
    if (!this._protoEdit) return;
    this._protoEdit.name = (v || "").toString().slice(0, 120);
  }

  // v15.7.1.5 — iOS: keep playback start inside user gesture (no Promise microtask)
  protoSetLoopEnabled(isEnabled) {
    if (!this._protoEdit) return;
    const enabled = !!isEnabled;
    const current = this._sanitizeLoopCount(this._protoEdit.loopCount ?? this._protoEdit.loops ?? 1);

    if (enabled) {
      const remembered = this._sanitizeLoopCount(this._protoEdit._lastLoopCount ?? current);
      this._protoEdit.loopCount = Math.max(2, remembered);
    } else {
      if (current > 1) this._protoEdit._lastLoopCount = current;
      this._protoEdit.loopCount = 1;
    }

    this.renderProtocolsUI();
  }

  protoSetLoopCount(v) {
    if (!this._protoEdit) return;
    let n = this._sanitizeLoopCount(v);

    // If user is editing loop count (input is enabled), keep it >= 2.
    const currentlyEnabled = this._sanitizeLoopCount(this._protoEdit.loopCount ?? 1) > 1;
    if (currentlyEnabled) n = Math.max(2, n);

    this._protoEdit.loopCount = n;
    if (n > 1) this._protoEdit._lastLoopCount = n;
    this.renderProtocolsUI();
  }

  async protoSave() {
    if (!this._protoEdit || !this.db?.putProtocol) return;
    const p = this._protoEdit;
    if (!p.name || !p.name.trim()) p.name = "Protokol";
    if (!Array.isArray(p.steps)) p.steps = [];
    p.loopCount = this._sanitizeLoopCount(p.loopCount ?? p.loops ?? 1);
    // prune invalid steps
    p.steps = p.steps.filter(s => {
      const f = s?.freq || {};
      const hz = Number(f.value ?? f.hz) || 0;
      const min = Number(s.minutes||0) || 0;
      return hz > 0 && min > 0;
    });
    try {
      await this.db.putProtocol(p);
      await this.loadProtocolsFromDB();
      this._protoEdit = null;
      this.renderProtocolsUI();
      this.showToast("✅ Protokol sačuvan.", { actionLabel: "Protokoli", actionNav: "protocols" });
    } catch(e) {
      alert("Ne mogu da sačuvam protokol: " + (e?.message || e));
    }
  }

  protoMoveStep(idx, delta) {
    if (!this._protoEdit) return;
    const steps = this._protoEdit.steps || [];
    const i = Number(idx);
    const d = Number(delta);
    if (!Number.isFinite(i) || !Number.isFinite(d)) return;
    const j = i + d;
    if (j < 0 || j >= steps.length) return;
    const tmp = steps[i];
    steps[i] = steps[j];
    steps[j] = tmp;
    this._protoEdit.steps = steps;
    this.renderProtocolsUI();
  }

  protoRemoveStep(idx) {
    if (!this._protoEdit) return;
    const i = Number(idx);
    if (!Number.isFinite(i)) return;
    this._protoEdit.steps = (this._protoEdit.steps || []).filter((_,k)=>k!==i);
    this.renderProtocolsUI();
  }

  protoAddManual() {
    if (!this._protoEdit) return;
    const hz = Number(document.getElementById("proto_hz")?.value || 0);
    const min = Number(document.getElementById("proto_min")?.value || 0);
    const lbl = (document.getElementById("proto_lbl")?.value || "").toString().trim();

    if (!hz || hz <= 0) return alert("Unesi Hz.");
    if (!min || min <= 0) return alert("Unesi trajanje (min).");

    const freq = { value: hz, hz, funkcija: lbl || "Custom", opis: "", izvor: "user", note: lbl || "" };
    this._protoEdit.steps = this._protoEdit.steps || [];
    this._protoEdit.steps.push({ minutes: min, freq });

    // clear inputs
    try { document.getElementById("proto_hz").value=""; } catch(_) {}
    try { document.getElementById("proto_min").value=""; } catch(_) {}
    try { document.getElementById("proto_lbl").value=""; } catch(_) {}
    this.renderProtocolsUI();
  }

  protoAppendFromFavorites() {
    if (!this._protoEdit) return;
    const ids = Array.from(this._favSet || []);
    const items = ids.map(id => this.catalogItems.find(x => x.id === id)).filter(Boolean);
    const steps = [];
    for (const it of items) steps.push(...this._expandSymptomToSteps(it, null, `⭐ ${it.simptom}`));
    this._protoEdit.steps = (this._protoEdit.steps || []).concat(steps);
    this.renderProtocolsUI();
  }

  protoAppendFromQueue() {
    if (!this._protoEdit) return;
    const items = Array.isArray(this.playlist) ? this.playlist : [];
    const steps = [];
    for (const it of items) steps.push(...this._expandSymptomToSteps(it, Number(it.userPerFreqMin)||null, `🎵 ${it.simptom}`));
    this._protoEdit.steps = (this._protoEdit.steps || []).concat(steps);
    this.renderProtocolsUI();
  }

  protoSearch() {
    if (!this._protoEdit) return;
    const q = (document.getElementById("proto_search")?.value || "").toString().trim().toLowerCase();
    const box = document.getElementById("proto_search_results");
    if (!box) return;

    if (!q) { box.innerHTML = "<div class='muted'>Unesi pojam.</div>"; return; }

    // Search symptoms first (by name)
    const hitsItems = (this.catalogItems || []).filter(it => (it.simptom||"").toString().toLowerCase().includes(q)).slice(0, 6);

    // Search individual frequencies by label or Hz exact/partial
    const hitsFreq = [];
    const hzQ = Number(q);
    for (const it of (this.catalogItems || [])) {
      const freqs = (it.frekvencije || []).filter(f=>f && f.enabled!==false);
      for (const f of freqs) {
        const hz = Number(f.value ?? f.hz) || 0;
        const label = (f.svrha || f.funkcija || f.desc || f.naziv || "").toString().toLowerCase();
        if (Number.isFinite(hzQ) && hzQ>0 && Math.abs(hz - hzQ) < 0.001) {
          hitsFreq.push({ it, f, hz });
        } else if (label && label.includes(q)) {
          hitsFreq.push({ it, f, hz });
        }
        if (hitsFreq.length >= 10) break;
      }
      if (hitsFreq.length >= 10) break;
    }

    const htmlItems = hitsItems.map(it => {
      const perMin = Math.max(1, Number(it.trajanjePoFrekvencijiMin)||5);
      return `<div class="proto-hit">
        <div style="flex:1;">
          <div><b>${this.escapeHtml(it.simptom)}</b></div>
          <div class="muted">Dodaje sve frekvencije (${(it.frekvencije||[]).filter(f=>f&&f.enabled!==false).length}) • ${perMin} min / frekv.</div>
        </div>
        <button class="btn-mini" onclick="window.app.protoAddSymptom('${this.escapeAttr(it.id)}')">➕ Dodaj</button>
      </div>`;
    }).join("");

    const htmlFreq = hitsFreq.map(h => {
      const label = (h.f.svrha || h.f.funkcija || h.f.desc || h.f.naziv || "").toString();
      return `<div class="proto-hit">
        <div style="flex:1;">
          <div><b>${h.hz} Hz</b> <span class="muted">— ${this.escapeHtml(label||'')}</span></div>
          <div class="muted">(${this.escapeHtml(h.it.simptom)})</div>
        </div>
        <button class="btn-mini" onclick="window.app.protoAddFreq('${this.escapeAttr(h.it.id)}','${this.escapeAttr(String(h.hz))}')">➕ Dodaj</button>
      </div>`;
    }).join("");

    box.innerHTML = `
      ${htmlItems ? `<div style="font-weight:900; margin:6px 0;">Simptomi</div>${htmlItems}` : ""}
      ${htmlFreq ? `<div style="font-weight:900; margin:10px 0 6px;">Pojedinačne frekvencije</div>${htmlFreq}` : ""}
      ${(!htmlItems && !htmlFreq) ? "<div class='muted'>Nema rezultata.</div>" : ""}
    `;
  }

  protoAddSymptom(itemId) {
    if (!this._protoEdit) return;
    const it = (this.catalogItems || []).find(x => x.id === itemId);
    if (!it) return;
    const steps = this._expandSymptomToSteps(it, null, `📚 ${it.simptom}`);
    this._protoEdit.steps = (this._protoEdit.steps || []).concat(steps);
    this.renderProtocolsUI();
  }

  protoAddFreq(itemId, hzStr) {
    if (!this._protoEdit) return;
    const it = (this.catalogItems || []).find(x => x.id === itemId);
    if (!it) return;
    const hzQ = Number(hzStr) || 0;
    if (!hzQ) return;
    const f0 = (it.frekvencije || []).find(f => Math.abs((Number(f.value ?? f.hz)||0) - hzQ) < 0.001);
    if (!f0) return;

    const perMin = Math.max(1, Number(it.trajanjePoFrekvencijiMin)||5);
    const step = this._clone(f0);
    step.value = hzQ;
    step.hz = hzQ;
    step.note = `(${it.simptom})`;
    this._protoEdit.steps = (this._protoEdit.steps || []).concat([{ minutes: perMin, freq: step }]);
    this.renderProtocolsUI();
  }

  async deleteProtocolById(id) {
    if (!id) return;
    if (!confirm("Obrisati protokol?")) return;
    try {
      await this.db?.deleteProtocol?.(id);
      await this.loadProtocolsFromDB();
      this.renderProtocolsUI();
      this.showToast("🗑 Protokol obrisan.", { actionLabel: "Protokoli", actionNav: "protocols" });
    } catch(e) {
      alert("Ne mogu da obrišem protokol: " + (e?.message || e));
    }
  }

  async exportProtocols() {
    try {
      await this.loadProtocolsFromDB();
      const payload = { format: "SINET_PROTOCOLS_v1", exportedAt: new Date().toISOString(), protocols: this.protocols || [] };
      const blob = new Blob([JSON.stringify(payload, null, 2)], { type: "application/json" });
      const a = document.createElement("a");
      a.href = URL.createObjectURL(blob);
      a.download = `SINET_PROTOCOLS_${new Date().toISOString().slice(0,10)}.json`;
      a.click();
      URL.revokeObjectURL(a.href);
      this.log("USER", "Protocols Export", "");
    } catch(e) {
      alert("Export nije uspeo: " + (e?.message || e));
    }
  }

  exportSingleProtocol(id) {
    const p = (this.protocols || []).find(x => x.id === id);
    if (!p) return;
    const payload = { format: "SINET_PROTOCOL_v1", exportedAt: new Date().toISOString(), protocol: p };
    const blob = new Blob([JSON.stringify(payload, null, 2)], { type: "application/json" });
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = `SINET_PROTOCOL_${id}.json`;
    a.click();
    URL.revokeObjectURL(a.href);
    this.log("USER", "Protocol Export", id);
  }

  importProtocolsPrompt() {
    const inp = document.createElement("input");
    inp.type = "file";
    inp.accept = "application/json";
    inp.onchange = async () => {
      const file = inp.files?.[0];
      if (!file) return;
      try {
        const text = await file.text();
        const payload = JSON.parse(text);
        const arr = payload?.protocols ? payload.protocols : (payload?.protocol ? [payload.protocol] : []);
        if (!Array.isArray(arr) || !arr.length) throw new Error("Nema protokola u fajlu.");

        for (const p0 of arr) {
          if (!p0 || typeof p0 !== "object") continue;
          const p = this._clone(p0);
          if (!p.id) p.id = this._newProtoId();
          if (!Array.isArray(p.steps)) p.steps = [];
          // avoid id clashes by suffix
          const exists = (this.protocols || []).some(x => x.id === p.id);
          if (exists) p.id = this._newProtoId();
          await this.db.putProtocol(p);
        }

        await this.loadProtocolsFromDB();
        this.renderProtocolsUI();
        this.showToast("✅ Uvoz protokola uspešan.", { actionLabel: "Protokoli", actionNav: "protocols" });
        this.log("USER", "Protocols Import", "");
      } catch(e) {
        alert("Uvoz nije uspeo: " + (e?.message || e));
      } finally {
        try { inp.value = ""; } catch(_) {}
      }
    };
    inp.click();
  }

  async createProtocolFromFavorites() {
    const ids = Array.from(this._favSet || []);
    const items = ids.map(id => this.catalogItems.find(x => x.id === id)).filter(Boolean);
    const steps = [];
    for (const it of items) steps.push(...this._expandSymptomToSteps(it, null, `⭐ ${it.simptom}`));
    this._protoEdit = { id: this._newProtoId(), name: `Favoriti • ${new Date().toISOString().slice(0,10)}`, loopCount: 1, steps };
    this.nav("protocols");
    this.renderProtocolsUI();
  }

  async createProtocolFromQueue() {
    const items = Array.isArray(this.playlist) ? this.playlist : [];
    const steps = [];
    for (const it of items) steps.push(...this._expandSymptomToSteps(it, Number(it.userPerFreqMin)||null, `🎵 ${it.simptom}`));
    this._protoEdit = { id: this._newProtoId(), name: `Lista • ${new Date().toISOString().slice(0,10)}`, loopCount: 1, steps };
    this.nav("protocols");
    this.renderProtocolsUI();
  }

  async playUserProtocolById(id, resume=null) {
    const p = (this.protocols || []).find(x => x.id === id) || await this.db?.getProtocol?.(id);
    if (!p) return alert("Ne mogu da nađem protokol.");
    const steps0 = Array.isArray(p.steps) ? p.steps : [];
    const loops = this._sanitizeLoopCount(p.loopCount ?? p.loops ?? 1);
    const steps = this._repeatSteps(steps0, loops);
    const { seq, durs, totalSec } = this._stepsToSequence(steps);
    if (!seq.length) return alert("Protokol nema koraka.");

    const startIndex = resume?.freqIndex || 0;
    const elapsedInFreq = resume?.elapsedInFreqSec || 0;

    this.selectedItem = { id: p.id, simptom: p.name || "Protokol" };
    this.isPlaylistActive = false;

    // iOS PRO (Rendered WAV): render protocol to WAV-in-RAM and play via <audio>
    if (this._isIOS && this.isIosBgRenderedEnabled()) {
      let resumeTrackSec = 0;
      for (let i=0;i<startIndex;i++) resumeTrackSec += (Number(durs[i])||0);
      resumeTrackSec += Math.max(0, Number(elapsedInFreq) || 0);

      const r = await this._startRenderedTrack({
        sequence: seq,
        durationsSec: durs,
        totalSec,
        resumeTrackSec,
        titleText: `[PROTO${loops>1 ? ' x'+loops : ''}] ${(p.name || 'Protokol').toString()}`,
        loopAll: false
      });
      if (r && r.fallback === false) {
        if (this.ui.btnPlayPause) this.ui.btnPlayPause.innerText = "⏸";
        this.log("PLAYER", "Play Protocol (iOS PRO Rendered)", p.id);
        return;
      }
      // else: fallback to live WebAudio
    }

    this.audio.loadSequence(seq, totalSec, startIndex, elapsedInFreq, durs);

    if (this.ui.playerDock) { this.ui.playerDock.style.display = 'block'; requestAnimationFrame(() => this._syncDockPadding(false)); }
    if (this.ui.nowPlayingPanel) this.ui.nowPlayingPanel.style.display = 'block';
    const btnNowList = document.getElementById('btn-nowlist');
    if (btnNowList) btnNowList.innerHTML = '▾ FREKVENCIJE';

    if (this.ui.pTitle) this.ui.pTitle.innerText = `[PROTO${loops>1 ? ' x'+loops : ''}] ${(p.name || 'Protokol').toString()}`;
    if (this.ui.pProtocolTimer) this.ui.pProtocolTimer.style.display = 'none';

    this._ensurePlaybackSession();
    this.audio.play();
    if (this.ui.btnPlayPause) this.ui.btnPlayPause.innerText = "⏸";
    this.log("PLAYER", "Play Protocol", p.id);
  }


  /* ===================== FAVORITES ===================== */

  // v15.4.7 — fast favorite lookup
  async refreshFavoritesSet() {
    if (!this.db) { this._favSet = new Set(); return; }
    try {
      const favs = await this.db.getFavorites();
      const ids = (Array.isArray(favs) ? favs : []).map(f => (f?.id || f)).filter(Boolean);
      this._favSet = new Set(ids);
    } catch (e) {
      this._favSet = new Set();
    }
  }

  isFavoriteId(id) {
    return !!(this._favSet && this._favSet.has(id));
  }

  // Toggle favorite from any list button (catalog, playlist, etc.)
  async toggleFavoriteQuick(id, btnEl = null) {
    if (!this.db || !id) return;
    try {
      const nowFav = await this.db.toggleFavorite(id);
      if (nowFav) this._favSet.add(id); else this._favSet.delete(id);

      // Update button label immediately
      if (btnEl) {
        btnEl.innerHTML = nowFav ? "⭐ <span class=\"btn-label\">Favorit</span>" : "☆ <span class=\"btn-label\">Favorit</span>";
        btnEl.setAttribute("aria-pressed", nowFav ? "true" : "false");
        btnEl.title = nowFav ? "Ukloni iz favorita" : "Dodaj u favorite";
      }

      // If modal is open for the same id, sync its state
      if (this.currentModalId === id) await this.refreshModalFavoriteUI();

      // If Favorites page is visible, refresh list
      if (this.currentPageId === 'favorites') this.updateFavorites();

      this.showToast(nowFav ? "Dodato u favorite ⭐" : "Uklonjeno iz favorita", { actionLabel: "Favoriti", actionNav: "favorites" });
      this.log("USER", "Toggle Favorite Quick", id);
    } catch (e) {
      this.showToast("Greška: ne mogu da sačuvam favorit.", {});
      this.log("ERROR", "Toggle Favorite Quick Failed", e?.message || "unknown");
    }
  }

  async refreshModalFavoriteUI() {
    const btn = document.getElementById('btn-qs-fav');
    if (!btn || !this.db || !this.currentModalId) return;

    // Prefer cached set; refresh if empty
    try {
      if (!this._favSet || this._favSet.size === 0) await this.refreshFavoritesSet();
    } catch (_) {}

    const isFav = this.isFavoriteId(this.currentModalId);

    btn.dataset.fav = isFav ? "1" : "0";
    btn.innerText = isFav ? "⭐ FAVORIT" : "☆ FAVORIT";
    btn.setAttribute("aria-pressed", isFav ? "true" : "false");
    btn.title = isFav ? "Ukloni iz favorita" : "Dodaj u favorite";
  }

  async toggleFavoriteFromModal() {
    if (!this.db || !this.currentModalId) return;
    try {
      const nowFav = await this.db.toggleFavorite(this.currentModalId);
      if (nowFav) this._favSet.add(this.currentModalId); else this._favSet.delete(this.currentModalId);
      await this.refreshModalFavoriteUI();
      this.showToast(nowFav ? "Dodato u favorite ⭐" : "Uklonjeno iz favorita", { actionLabel: "Favoriti", actionNav: "favorites" });
      this.log("USER", "Toggle Favorite", this.currentModalId);
    } catch (e) {
      this.showToast("Greška: ne mogu da sačuvam favorit.", {});
      this.log("ERROR", "Toggle Favorite Failed", e?.message || "unknown");
    }
  }

  // Backward compatibility (older UI calls)
  async toggleFavoriteCurrent() {
    return this.toggleFavoriteFromModal();
  }

  
  async updateFavorites() {
    const cont = document.getElementById('favorites-list');
    if (!cont) return;
    cont.innerHTML = "";

    try {
      if (!this._favSet || this._favSet.size === 0) await this.refreshFavoritesSet();
      const favs = Array.from(this._favSet || []);

      if (!favs.length) { cont.innerHTML = "<p style='text-align:center'>Nema favorita.</p>"; return; }

      favs.forEach(fid => {
        const it = this.catalogItems.find(x => x.id === fid);
        if (!it) return;

        const mkbCode = this.getMKB10Code(it.mkb10);
        const mkbDesc = this.getMKB10Desc(it.mkb10);
        const mkbBadge = mkbCode ? `<span class="mkb-badge" style="background:#eef3ff; font-size:0.75rem; padding:2px 6px; border-radius:7px; margin-left:6px;">${this.escapeHtml(mkbCode)}</span>` : "";

        const short = (it.opis || it.desc || "").toString().trim().slice(0, 90);

        cont.innerHTML += `
          <div class="cat-item">
            <div class="cat-main" onclick="app.openModal('${it.id}')">
              <div class="cat-title">⭐ ${this.escapeHtml(it.simptom)} ${mkbBadge}</div>
              <div class="cat-sub">${this.escapeHtml(short || "Klikni za detalje i frekvencije.")}</div>
              <div class="cat-sub" style="margin-top:3px;">🏷️ MKB-10: ${mkbCode || mkbDesc ? `${this.escapeHtml(mkbCode || "")}${(mkbCode && mkbDesc) ? " — " : ""}${this.escapeHtml((mkbDesc || "").slice(0,80))}` : `<span class="muted">nije popunjeno</span>`}</div>
            </div>
            <div class="cat-actions">
              <button class="btn-add-playlist" title="Dodaj u listu" onclick="event.stopPropagation(); app.quickAddToPlaylist('${it.id}')">➕ <span class="btn-label">U listu</span></button>
              <button class="cat-mini-btn" title="Ukloni iz favorita" onclick="event.stopPropagation(); app.toggleFavoriteQuick('${it.id}', null)">✖ <span class="btn-label">Ukloni</span></button>
            </div>
          </div>
        `;
      });

      this.log("DATA", "Favorites Render", String(favs.length));
    } catch(e) {
      cont.innerHTML = "<p style='text-align:center; color:#c0392b'>Greška učitavanja favorita.</p>";
      console.error(e);
      this.log("ERROR", "Favorites Failed", e.message);
    }
  }


  /* ===================== BACKUP / RESTORE ===================== */

// Backward-compatible UI hooks (index.html expects exportData/importData)
async exportData() { return this.exportBackup(); }

async importData(fileInput) {
  try {
    const file = fileInput?.files?.[0];
    if (!file) return;
    const text = await file.text();
    const payload = JSON.parse(text);

    // 1) DB restore
    await this.db.importAll(payload);

    // 2) LocalStorage restore (user symptoms / overrides / settings)
    try {
      const loc = payload?.local || {};
      if (typeof loc.userSymptoms === "string") localStorage.setItem("sinet_user_symptoms_v1", loc.userSymptoms);
      if (typeof loc.overrides === "string") localStorage.setItem("sinet_overrides_v1", loc.overrides);
      if (typeof loc.iosBgExperimental === "string") localStorage.setItem("sinet_ios_bg_experimental", loc.iosBgExperimental);
    } catch(_) {}

    // 3) Reload in-memory state + UI
    await this.refreshFavoritesSet();
    await this.loadPlaylistFromDB();
    await this.loadProtocolsFromDB();
    await this.loadUserSymptoms();
    await this.loadOverrides();
    this.applyUserDataToCatalog();

    this.renderSystemPresets();
    this.showCatalogHome();
    this.renderPlaylistUI();
    this.updateFavorites?.();

    alert("Uvoz uspešan ✅");
    this.log("USER", "Backup Import", "");
  } catch(e) {
    alert("Uvoz nije uspeo: " + (e?.message || e));
    this.log("ERROR", "Backup Import Failed", e?.message || "unknown");
  } finally {
    try { if (fileInput) fileInput.value = ""; } catch(_) {}
  }

  }

  async exportBackup() {
  try {
    const payload = await this.db.exportAll();

    // Include local-only user data (not in IndexedDB)
    payload.local = {};
    try { payload.local.userSymptoms = localStorage.getItem("sinet_user_symptoms_v1") || ""; } catch(_) {}
    try { payload.local.overrides = localStorage.getItem("sinet_overrides_v1") || ""; } catch(_) {}
    try { payload.local.iosBgExperimental = localStorage.getItem("sinet_ios_bg_experimental") || "0"; } catch(_) {}

    const blob = new Blob([JSON.stringify(payload, null, 2)], { type: "application/json" });
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = `SINET_BACKUP_${new Date().toISOString().slice(0,10)}.json`;
    a.click();
    URL.revokeObjectURL(a.href);
    this.log("USER", "Backup Export", "");
  } catch(e) {
    alert("Backup nije uspeo: " + e.message);
    this.log("ERROR", "Backup Export Failed", e.message);
  }
  }

  importBackupPrompt() {
    const inp = document.createElement("input");
    inp.type = "file";
    inp.accept = "application/json";
    inp.onchange = async () => {
      const file = inp.files?.[0];
      if (!file) return;
      const text = await file.text();
      try {
        const payload = JSON.parse(text);
        await this.db.importAll(payload);
        await this.loadPlaylistFromDB();
    await this.loadProtocolsFromDB();

    // optional offline registry (images, licensing)
    await this.loadAcupressureRegistry();
        this.renderPlaylistUI();
        alert("Restore uspešan.");
      } catch(e) {
        alert("Restore nije uspeo: " + e.message);
      }
    };
    inp.click();
  }

  /* ===================== AUDIT LOG UI ===================== */
  async openAuditLog() {
    const modal = document.getElementById("audit-modal");
    const box = document.getElementById("audit-table");
    if (!modal || !box) return;
    const rows = await this.db.getAuditLog(500);

    box.innerHTML = `
      <table style="width:100%; border-collapse:collapse; font-size:0.9rem;">
        <thead>
          <tr>
            <th style="text-align:left; padding:8px; border-bottom:1px solid #ddd;">Time</th>
            <th style="text-align:left; padding:8px; border-bottom:1px solid #ddd;">Category</th>
            <th style="text-align:left; padding:8px; border-bottom:1px solid #ddd;">Action</th>
            <th style="text-align:left; padding:8px; border-bottom:1px solid #ddd;">Details</th>
          </tr>
        </thead>
        <tbody>
          ${rows.map(r => `
            <tr>
              <td style="padding:8px; border-bottom:1px solid #eee; white-space:nowrap;">${r.timestamp}</td>
              <td style="padding:8px; border-bottom:1px solid #eee; font-weight:800;">${r.category}</td>
              <td style="padding:8px; border-bottom:1px solid #eee;">${r.action}</td>
              <td style="padding:8px; border-bottom:1px solid #eee;">${r.details||""}</td>
            </tr>`).join("")}
        </tbody>
      </table>
    `;
    modal.style.display = "flex";
    this.log("UI", "Open Audit", "");
  }

  closeAuditLog() {
    const modal = document.getElementById("audit-modal");
    if (modal) modal.style.display = "none";
  }

  async downloadAuditLog() {
    const rows = await this.db.getAuditLog(5000);
    const blob = new Blob([JSON.stringify(rows, null, 2)], { type: "application/json" });
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = `SINET_AUDIT_${new Date().toISOString().slice(0,10)}.json`;
    a.click();
    URL.revokeObjectURL(a.href);
    this.log("USER", "Audit Export", "");
  }

  
  /* ===================== v15.3 — PRESETS (Seniors + Hitno) ===================== */

  async loadSeniorPresets() {
    const url = 'data/presets/senior_presets.json';
    try {
      const res = await fetch(url, { cache: "no-store" });
      if (!res.ok) throw new Error(`${url} nije pronađen (${res.status})`);
      this.seniorPresets = await res.json();
      this.log("DATA", "Senior Presets Loaded", url);
    } catch (e) {
      this.seniorPresets = null;
      console.warn("Senior presets not loaded:", e?.message || e);
      this.log("DATA", "Senior Presets Missing", e?.message || "unknown");
    }
  }

  _norm(str) {
    return (str || "")
      .toString()
      .toLowerCase()
      .normalize('NFKD')
      .replace(/[\u0300-\u036f]/g, '')
      .replace(/[^a-z0-9čćšđž\s-]/g, ' ')
      .replace(/\s+/g, ' ')
      .trim();
  }

  renderSystemPresets() {
    const container = document.getElementById('presets-container');
    if (!container) return;

    let html = "";

    // 1) Seniors (always above HITNO)
    const g0 = this.seniorPresets?.groups?.find(g => g.id === "senior") || this.seniorPresets?.groups?.[0];
    if (g0 && Array.isArray(g0.entries) && g0.entries.length) {
      const limit = this.seniorShowAll ? g0.entries.length : (Number(g0.defaultLimit) || 30);
      html += `<div class="preset-category-title">${g0.title || "🧓 STARIJI — Najčešće"}</div>`;
      html += `<div class="preset-grid">`;
      g0.entries.slice(0, limit).forEach((e, idx) => {
        const sub = (e.terms || []).slice(0, 2).join(" • ");
        html += `
          <div class="preset-chip" onclick="app.openSeniorPreset(${idx})" role="button" aria-label="Otvori ${this.escapeHtml(e.label)}">
            <div class="ico">⚡</div>
            <div class="txt">
              <div class="t">${this.escapeHtml(e.label)}</div>
              <div class="s">${this.escapeHtml(sub || "klikni za detalje")}</div>
            </div>
          </div>
        `;
      });
      html += `</div>`;

      if (g0.entries.length > (Number(g0.defaultLimit) || 30)) {
        html += `
          <div class="preset-morebar">
            <button onclick="app.toggleSeniorShowAll()">${this.seniorShowAll ? "Prikaži manje" : `Prikaži sve (${g0.entries.length})`}</button>
            <button onclick="nav('catalog')">Otvori katalog</button>
          </div>
        `;
      }
    }

    // 2) HITNO (akutno) — derive from catalog
    const hitnoItems = (this.catalogItems || []).filter(it => {
      const g = (it.quickGroup || "").toLowerCase();
      const o = (it.oblast || "").toLowerCase();
      const id = String(it.id || "");
      return id.startsWith("sys-hitno") || g.includes("prva pomoć") || g.includes("prva pomoc") || o.includes("hitno") || g.includes("akut");
    }).slice(0, 10);

    if (hitnoItems.length) {
      html += `<div class="preset-category-title">🚨 HITNO (akutno)</div>`;
      hitnoItems.forEach(it => {
        const short = (it.opis || "").toString().trim().slice(0, 85);
        html += `
          <div class="preset-item" onclick="app.openModal('${it.id}')">
            <div class="preset-info">
              <div style="font-weight:900; color:#333;">⚡ ${this.escapeHtml(it.simptom)}</div>
              <div style="font-size:0.82rem; color:#777;">${this.escapeHtml(short)}</div>
            </div>
            <div class="play-icon">▶</div>
          </div>
        `;
      });
    }

    container.innerHTML = html;
  }

  toggleSeniorShowAll() {
    this.seniorShowAll = !this.seniorShowAll;
    this.renderSystemPresets();
  }

  openSeniorPreset(idx) {
    const g0 = this.seniorPresets?.groups?.find(g => g.id === "senior") || this.seniorPresets?.groups?.[0];
    const entry = g0?.entries?.[Number(idx)];
    if (!entry) return;

// If catalog isn't loaded, preset resolution cannot work (common on iOS when SW-cache breaks /data fetch)
if (!Array.isArray(this.catalogItems) || this.catalogItems.length === 0) {
  const st = (this._catalogLoad && this._catalogLoad.state) ? this._catalogLoad.state : "unknown";
  this.showToast(`⚠️ Katalog nije spreman (state: ${st}). Sačekaj 5–10s ili tapni 🔄 Retry.`, {
    timeoutMs: 12000,
    action2Label: "🔄 Retry",
    action2Onclick: "window.app && window.app.retryCatalog && window.app.retryCatalog()"
  });
  return;
}

    const found = this.resolvePresetEntry(entry);
    if (found) return this.openModal(found.id);

    // Fallback: AI Upitnik (prefill)
    this.prefillAI(entry.label, "", "Nije pronađeno u katalogu — koristi AI upitnik 🙂");
    this.nav('ai');
  }

  resolvePresetEntry(entry) {
    const label = entry?.label || "";
    const lab = this._norm(label);

    // 1) Explicit preferred IDs (best)
    const preferIds = Array.isArray(entry?.preferIds) ? entry.preferIds : [];
    for (const pid of preferIds) {
      const it = this.catalogItems.find(x => x.id === pid);
      if (it) return it;
    }

    // 2) Special-case: "Zubobolja & infekcija" can incorrectly match to UTI.
    if (lab.includes("zubobolja")) {
      const z = (this.catalogItems || []).find(it =>
        this._norm(it.simptom || "").includes("zubobolja") &&
        (it.seniorQuick === true || String(it.quickGroup || "").toLowerCase().includes("zubi") || it.favoritesDefault === true)
      );
      if (z) return z;
    }

    const terms = Array.isArray(entry?.terms) ? entry.terms : [];
    const want = terms.filter(Boolean).map(t => this._norm(t)).filter(Boolean);

    // Primary term heuristic: first term OR first segment before '&' / '+' / '/'
    const primaryFromLabel = this._norm((label || "").split(/[&+\/]/)[0] || "");
    const primary = (want[0] || primaryFromLabel || "").trim();

    const allItems = (this.catalogItems || []);
    let candidates = allItems.filter(it => {
      const hay = this._norm(`${it.simptom || ""} ${it.id || ""} ${it.oblast || ""}`);
      if (want.length && want.some(t => hay.includes(t))) return true;
      if (lab && hay.includes(lab)) return true;
      if (primary && hay.includes(primary)) return true;
      return false;
    });

    // If primary exists, restrict to primary-matching candidates (prevents wrong matches)
    if (primary) {
      const strict = candidates.filter(it => {
        const hay = this._norm(`${it.simptom || ""} ${it.id || ""} ${it.oblast || ""}`);
        return hay.includes(primary);
      });
      if (strict.length) candidates = strict;
    }

    if (!candidates.length) return null;

    // Score by #term hits first, then seniorQuick/favDefault, then label hit.
    let best = null, bestScore = -1;
    for (const it of candidates) {
      const hay = this._norm(`${it.simptom || ""} ${it.id || ""} ${it.oblast || ""}`);
      let hitCount = 0;
      for (const t of want) if (t && hay.includes(t)) hitCount += 1;

      let score = hitCount * 10;
      if (primary && hay.includes(primary)) score += 6;
      if (lab && hay.includes(lab)) score += 3;

      if (it.seniorQuick === true) score += 5;
      if (it.favoritesDefault === true) score += 3;
      if (!String(it.id || "").startsWith("usr-")) score += 1;

      // Tie-breaker: longer symptom name often more specific
      score += Math.min(3, ((it.simptom || "").length / 50));

      if (score > bestScore) { bestScore = score; best = it; }
    }
    return best;
  }


  /* ===================== v15.3 — CATALOG (Oblasti-first, elder-friendly) ===================== */

  showCatalogHome() {
    this.activeOblast = null;
    const inp = document.getElementById('search-input');
    if (inp) inp.value = "";

    // FIX v15.4.4: if user previously opened an oblast, the grid may stay hidden.
    const grid = this.ui.catalogOblastGrid || document.getElementById('catalog-oblast-grid');
    if (grid) grid.style.display = 'grid';

    this.renderCatalogOblastGrid();
    if (this.ui.catalogList) this.ui.catalogList.innerHTML = "";
  }

  renderCatalogOblastGrid() {
    const grid = this.ui.catalogOblastGrid || document.getElementById('catalog-oblast-grid');
    if (!grid) return;

    // Ensure visible in case it was hidden by an opened oblast view.
    grid.style.display = 'grid';

    const items = this.catalogItems || [];
    const counts = new Map();
    for (const it of items) {
      const o = (it.oblast || "Ostalo").toString();
      counts.set(o, (counts.get(o) || 0) + 1);
    }

    const oblasts = Array.from(counts.entries())
      .sort((a,b)=> b[1]-a[1]) // most populated first
      .slice(0, 60);

    grid.innerHTML = oblasts.map(([oblast, n]) => `
      <div class="oblast-card" onclick="app.openOblast('${this.escapeAttr(oblast)}')">
        <div class="oblast-title">📌 ${this.escapeHtml(oblast)}</div>
        <div class="oblast-count">${n} stavki</div>
        <div class="oblast-cta">👉 Klikni za listu</div>
      </div>
    `).join("");
  }

  openOblast(oblast) {
    this.activeOblast = oblast;
    const inp = document.getElementById('search-input');
    if (inp) inp.value = "";

    const filtered = (this.catalogItems || []).filter(it => (it.oblast || "Ostalo") === oblast);
    this.renderCatalogList(filtered, `Oblast: ${oblast}`, true);
  }

  renderCatalogList(items, title = "", showBack = false) {
    const container = this.ui.catalogList || document.getElementById('catalog-list');
    if (!container) return;

    // Remember last rendered list (for TXT export)
    this.lastCatalogViewItems = Array.isArray(items) ? items.slice() : [];
    this.lastCatalogViewTitle = title || "";

    const grid = this.ui.catalogOblastGrid || document.getElementById('catalog-oblast-grid');
    if (grid) grid.style.display = showBack ? "none" : "grid";

    // Backbar
    let backHtml = "";
    if (showBack) {
      backHtml = `
        <div class="catalog-backbar">
          <button class="backbtn" onclick="app.showCatalogHome()">← Oblasti</button>
          <div class="label">${this.escapeHtml(title)}</div>
        </div>
      `;
    }

    if (!items || !items.length) {
      container.innerHTML = backHtml + "<p style='text-align:center; padding:20px;'>Nema rezultata.</p>";
      return;
    }

    // Flat list cards
    const html = items.map(it => {
      const short = (it.opis || it.desc || "").toString().trim().slice(0, 110);

      const mkbCode = this.getMKB10Code(it.mkb10);
      const mkbDesc = this.getMKB10Desc(it.mkb10);
      const mkbInline = (mkbCode || mkbDesc)
        ? `🏷️ MKB-10: ${this.escapeHtml(mkbCode || "")}${(mkbCode && mkbDesc) ? " — " : ""}${this.escapeHtml((mkbDesc || "").slice(0, 80))}`
        : `🏷️ MKB-10: <span class="muted">nije popunjeno</span>`;

      const mkbBadge = mkbCode
        ? `<span class="mkb-badge" style="background:#eef3ff; font-size:0.75rem; padding:2px 6px; border-radius:7px; margin-left:6px;">${this.escapeHtml(mkbCode)}</span>`
        : '';

      const isUser = String(it.id||"").startsWith("usr-");
      const isFav = this.isFavoriteId(it.id);

      return `
        <div class="cat-item">
          <div class="cat-main" onclick="app.openModal('${it.id}')">
            <div class="cat-title">${isUser ? "🧩 " : ""}${this.escapeHtml(it.simptom)} ${mkbBadge}</div>
            <div class="cat-sub">${this.escapeHtml(short || "Klikni za detalje i frekvencije.")}</div>
            <div class="cat-sub" style="margin-top:3px;">${mkbInline}</div>
          </div>
          <div class="cat-actions">
            <button class="btn-add-playlist" title="Dodaj u listu" aria-label="Dodaj u listu" onclick="event.stopPropagation(); app.quickAddToPlaylist('${it.id}')">➕ <span class="btn-label">U listu</span></button>
            <button class="cat-mini-btn btn-fav" title="${isFav ? "Ukloni iz favorita" : "Dodaj u favorite"}" aria-label="Favorit" aria-pressed="${isFav ? "true" : "false"}" onclick="event.stopPropagation(); app.toggleFavoriteQuick('${it.id}', this)">${isFav ? "⭐" : "☆"} <span class="btn-label">Favorit</span></button>
            ${isUser ? `<button class="cat-mini-btn" title="Izmeni" onclick="event.stopPropagation(); app.editUserSymptom('${it.id}')">✎ <span class="btn-label">Edit</span></button>` : `<button class="cat-mini-btn" title="AI upitnik" onclick="event.stopPropagation(); app.prefillAI('${this.escapeAttr(it.simptom)}', '${this.escapeAttr(short)}'); nav('ai');">🤖 <span class="btn-label">AI</span></button>`}
          </div>
        </div>
      `;
    }).join("");

    container.innerHTML = backHtml + html;
  }


  filterCatalog(query = null) {
    const q = (query !== null ? query : (document.getElementById('search-input')?.value || "")).toString().trim();
    const nq = this._norm(q);

    if (!nq) {
      if (this.activeOblast) return this.openOblast(this.activeOblast);
      return this.showCatalogHome();
    }

    const items = (this.catalogItems || []).filter(it => {
      const mkb = `${this.getMKB10Code(it.mkb10)} ${this.getMKB10Desc(it.mkb10)} ${this.getMKB10Url(it.mkb10)}`;
      const hay = this._norm(`${it.simptom || ""} ${it.oblast || ""} ${it.opis || ""} ${mkb}`);
      return hay.includes(nq);
    });

    this.renderCatalogList(items, `Rezultati: ${q}`, true);
  }


  /* ===================== v15.4.5 — CATALOG TXT EXPORT ===================== */

  exportCatalogTxt(mode = "view") {
    try {
      const items = this._getCatalogExportItems(mode);
      if (!items || !items.length) return alert("Nema stavki za izvoz.");

      const now = new Date();
      const date = now.toISOString().slice(0, 10);

      const scopeLabel = (mode === "all")
        ? "CELOKUPAN KATALOG"
        : (this.lastCatalogViewTitle || this.activeOblast ? ("PRIKAZ: " + (this.lastCatalogViewTitle || this.activeOblast)) : "PRIKAZ");

      const txt = this._formatCatalogTxt(items, {
        date,
        scopeLabel
      });

      const fnameSafe = (mode === "all" ? "SVE" : "PRIKAZ");
      const filename = `SINET_KATALOG_${fnameSafe}_${date}.txt`;
      this._downloadText(txt, filename);

      this.log("USER", "Catalog TXT Export", `${mode} • ${items.length}`);
    } catch (e) {
      alert("Izvoz TXT nije uspeo: " + (e?.message || e));
      this.log("ERROR", "Catalog TXT Export Failed", e?.message || "unknown");
    }
  }

  _getCatalogExportItems(mode = "view") {
    const all = Array.isArray(this.catalogItems) ? this.catalogItems.slice() : [];

    if (mode === "all") return all;

    // Prefer exact current view items (oblast list or search results)
    if (Array.isArray(this.lastCatalogViewItems) && this.lastCatalogViewItems.length) {
      return this.lastCatalogViewItems.slice();
    }

    // Fallback: active oblast or search input
    const q = (document.getElementById('search-input')?.value || "").toString().trim();
    const nq = this._norm(q);

    if (nq) {
      return all.filter(it => {
        const hay = this._norm(`${it.simptom || ""} ${it.oblast || ""} ${it.opis || ""} ${this.getMKB10Code(it.mkb10) || ""} ${this.getMKB10Desc(it.mkb10) || ""}`);
        return hay.includes(nq);
      });
    }

    if (this.activeOblast) return all.filter(it => (it.oblast || "Ostalo") === this.activeOblast);

    return all;
  }

  _formatCatalogTxt(items, ctx = {}) {
    const date = ctx.date || new Date().toISOString().slice(0,10);
    const scopeLabel = ctx.scopeLabel || "KATALOG";

    // Group by oblast
    const groups = new Map();
    for (const it of items) {
      const oblast = (it.oblast || "Ostalo").toString();
      if (!groups.has(oblast)) groups.set(oblast, []);
      groups.get(oblast).push(it);
    }

    const oblastNames = Array.from(groups.keys()).sort((a,b)=> a.localeCompare(b, 'sr', { sensitivity:'base' }));

    let out = "";
    out += "==================================================\n";
    out += "SINET AUDIO LEKAR - EXPORT KATALOGA\n";
    out += "==================================================\n";
    out += `Datum: ${date}\n`;
    out += `Opseg: ${scopeLabel}\n`;
    out += `Stavki: ${items.length}\n`;
    out += "==================================================\n\n";

    for (const oblast of oblastNames) {
      const arr = groups.get(oblast) || [];
      arr.sort((a,b)=> (a.simptom||"").localeCompare(b.simptom||"", 'sr', { sensitivity:'base' }));

      out += "##################################################\n";
      out += `OBLAST: ${oblast}\n`;
      out += "##################################################\n\n";

      let n = 1;
      for (const it of arr) {
        const naziv = (it.simptom || it.naziv || "").toString().trim();
        const opis = (it.opis || it.desc || "").toString().trim();
        const id = (it.id || "").toString().trim();

        const mkbCode = this.getMKB10Code(it.mkb10);
        const mkbDesc = this.getMKB10Desc(it.mkb10);
        const mkbUrl  = this.getMKB10Url ? this.getMKB10Url(it.mkb10) : "";

        const h = it.holisticki || {};
        const psi = h.psihosomatika || {};
        const af  = h.afirmacija || {};
        const mol = h.molitva || h.duhovnost || {};
        const narOpis = (h.narodni_lek && (h.narodni_lek.opis || h.narodni_lek.tekst)) ? (h.narodni_lek.opis || h.narodni_lek.tekst) : (h.saveti?.narodno || "");

        const mkbLine = `MKB-10: code="${(mkbCode||"").toString().replace(/"/g,"'")}" | opis="${(mkbDesc||"").toString().replace(/"/g,"'")}" | url="${(mkbUrl||"").toString().replace(/"/g,"'")}"`;

        // Frequencies — full fields (even if empty)
        const freqsIn = Array.isArray(it.frekvencije) ? it.frekvencije : [];
        const freqLines = freqsIn
          .map(f => {
            const hz = Number(f?.hz ?? f?.value ?? 0) || 0;
            if (!hz) return null;
            const nazivF = (f?.naziv || "").toString().trim().replace(/"/g,"'");
            const opisF  = (f?.opis || "").toString().trim().replace(/"/g,"'");
            const funF   = (f?.funkcija || f?.svrha || f?.desc || "").toString().trim().replace(/"/g,"'");
            const srcF   = (f?.izvor || f?.src || "").toString().trim().replace(/"/g,"'");
            return `   - ${hz} Hz | naziv="${nazivF}" | opis="${opisF}" | funkcija="${funF}" | izvor="${srcF}"`;
          })
          .filter(Boolean);

        out += `${n}. ${naziv || "(bez naziva)"}\n`;
        out += "   ----------------------------------------------\n";
        if (id) out += `   ID: ${id}\n`;
        out += `   OPIS: ${(opis || "").toString().replace(/\n/g," ")}\n`;
        out += `   ${mkbLine}\n`;

        out += `   PSIHOSOMATIKA: uzrok="${(psi.uzrok||"").toString().replace(/"/g,"'")}" | lek="${(psi.lek||"").toString().replace(/"/g,"'")}"\n`;
        out += `   AFIRMACIJA: tekst="${(af.tekst||"").toString().replace(/"/g,"'")}" | autor="${(af.autor||"").toString().replace(/"/g,"'")}" | izvor="${(af.izvor||"").toString().replace(/"/g,"'")}"\n`;
        out += `   MOLITVA: tekst="${(mol.tekst||"").toString().replace(/"/g,"'")}" | izvor="${(mol.izvor||"").toString().replace(/"/g,"'")}"\n`;
        out += `   NARODNI_LEK: opis="${(narOpis||"").toString().replace(/"/g,"'")}"\n`;

        if (freqLines.length) {
          out += "   FREKVENCIJE:\n";
          out += freqLines.join("\n") + "\n";
        } else {
          out += "   FREKVENCIJE: (nema)\n";
        }

        out += "   ----------------------------------------------\n\n";
        n++;
      }

      out += "\n";
    }

    return out;
  }

  _wrapTxtLine(line, maxLen = 120, indent = "   ") {
    // Keeps words/segments split on ', ' where possible
    if (!line || line.length <= maxLen) return line + "\n";
    const parts = line.split(", ");
    let out = "";
    let cur = "";
    for (let i=0; i<parts.length; i++) {
      const seg = (i===0) ? parts[i] : (", " + parts[i]);
      if ((cur + seg).length <= maxLen) {
        cur += seg;
      } else {
        out += cur + "\n";
        cur = indent + parts[i];
      }
    }
    if (cur) out += cur + "\n";
    return out;
  }

  _downloadText(text, filename) {
    const blob = new Blob([text], { type: "text/plain;charset=utf-8" });
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = filename;
    a.click();
    URL.revokeObjectURL(a.href);
  }




  /* ===================== v15.4.7.4 — STL v1.1 JSON EXPORT ===================== */

  exportCatalogSTL(mode = "view") {
    try {
      const items = this._getCatalogExportItems(mode);
      if (!items || !items.length) return alert("Nema stavki za izvoz.");

      const now = new Date();
      const date = now.toISOString().slice(0, 10);

      const scopeLabel = (mode === "all")
        ? "CELOKUPAN KATALOG"
        : (this.lastCatalogViewTitle || this.activeOblast ? ("PRIKAZ: " + (this.lastCatalogViewTitle || this.activeOblast)) : "PRIKAZ");

      const stl = this._buildSTLPayload(items, { mode, scopeLabel });

      const fnameSafe = (mode === "all" ? "SVE" : "PRIKAZ");
      const filename = `SINET_STL_${fnameSafe}_${date}.json`;

      this._downloadJson(stl, filename);
      this.log("USER", "Catalog STL Export", `${mode} • ${items.length}`);
    } catch (e) {
      alert("Izvoz STL JSON nije uspeo: " + (e?.message || e));
      this.log("ERROR", "Catalog STL Export Failed", e?.message || "unknown");
    }
  }

  _downloadJson(obj, filename) {
    const text = JSON.stringify(obj, null, 2);
    const blob = new Blob([text], { type: "application/json;charset=utf-8" });
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = filename;
    a.click();
    URL.revokeObjectURL(a.href);
  }

  _buildSTLPayload(items, ctx = {}) {
    const now = new Date();
    const ts = now.toISOString();

    // Summary stats
    let freqTotal = 0;
    for (const it of items) {
      const freqs = Array.isArray(it?.frekvencije) ? it.frekvencije : [];
      freqTotal += freqs.filter(f => Number(f?.value ?? f?.hz ?? 0) > 0).length;
    }

    const simptomi = items.map(it => this._runtimeItemToSTL(it)).filter(Boolean);

    const meta = {
      schema: "SINET_STL",
      version: "1.1",
      generatedAt: ts,
      sourceFile: (ctx.mode === "all") ? "SINET_CATALOG (ALL)" : "SINET_CATALOG (VIEW)",
      notes: ctx.scopeLabel || "",
      audit: [{
        ts,
        tool: "SINET Audio Lekar",
        toolVersion: "15.4.7.4",
        mode: "manual",
        providers: [],
        summary: { simptomi: simptomi.length, freqTotal }
      }]
    };

    return { meta, simptomi };
  }

  _runtimeItemToSTL(it) {
    if (!it || !it.id) return null;

    const id = String(it.id).trim();
    const naziv = (it.simptom || it.naziv || "").toString();
    const opis = (it.opis || it.desc || "").toString();

    // Prefer rich object if present
    const mkbObj = it.mkb10_obj || it.mkb10 || null;

    // Holistics (runtime uses holisticki.*)
    const h = it.holisticki || {};
    const psi = h.psihosomatika || {};
    const af  = h.afirmacija || {};
    const mol = h.molitva || h.duhovnost || {};
    const nar = (h.narodni_lek?.opis !== undefined)
      ? h.narodni_lek
      : { opis: (h.saveti?.narodno || "") };

    // Frekvencije
    const perMin = Number(it.freq_duration_min ?? it.trajanjePoFrekvencijiMin ?? it.trajanje_po_frekvenciji_min ?? 0) || null;
    const freqsIn = Array.isArray(it.frekvencije) ? it.frekvencije : [];
    const frekvencije = freqsIn
      .map(f => this._runtimeFreqToSTL(f, perMin))
      .filter(Boolean);

    // Ensure stable full shape (even if empty)
    const stl = {
      id,
      uid: (it.uid !== undefined) ? it.uid : null,
      naziv: naziv || "",
      opis: opis || "",
      mkb10: this._mkb10ToCanonical(mkbObj),

      psihosomatika: {
        uzrok: (psi.uzrok || "").toString(),
        lek: (psi.lek || "").toString()
      },

      afirmacija: {
        tekst: (af.tekst || "").toString(),
        autor: (af.autor || "").toString(),
        izvor: (af.izvor || "").toString()
      },

      molitva: {
        tekst: (mol.tekst || "").toString(),
        izvor: (mol.izvor || "").toString()
      },

      narodni_lek: {
        opis: (nar.opis || nar.tekst || "").toString()
      },

      akupresura: (it.akupresura !== undefined ? it.akupresura : null),

      frekvencije,

      extensions: {
        player: {
          trajanje_po_frekvenciji_min: perMin,
          ukupno_trajanje_min: Number(it.ukupnoTrajanjeMin ?? 0) || null
        },
        runtime: {
          oblast: (it.oblast || "").toString(),
          podOblast: (it.podOblast || "").toString()
        }
      }
    };

    // If item was derived from STL earlier, preserve richer blocks if present,
    // but keep canonical keys stable (do NOT remove required canonical keys).
    if (it._stl && typeof it._stl === "object") {
      // Preserve akupresura if it exists in _stl and current is null/empty
      if ((stl.akupresura === null || stl.akupresura === undefined) && it._stl.akupresura !== undefined) {
        stl.akupresura = it._stl.akupresura;
      }
    }

    return stl;
  }

  _mkb10ToCanonical(mkb) {
    // Canonical target:
    // { code: "", opis: "", izvor?: { sistem,url,autor,delo,licenca } }
    if (!mkb) return { code: "", opis: "", izvor: { sistem: "ICD-10 / MKB-10", url: "", autor: "", delo: "", licenca: "" } };

    if (typeof mkb === "string") {
      return { code: mkb.trim(), opis: "", izvor: { sistem: "ICD-10 / MKB-10", url: "", autor: "", delo: "", licenca: "" } };
    }

    if (typeof mkb !== "object") {
      return { code: String(mkb), opis: "", izvor: { sistem: "ICD-10 / MKB-10", url: "", autor: "", delo: "", licenca: "" } };
    }

    const code = (mkb.code || mkb.sifra || mkb.sifra_mkb || mkb.icd10 || "").toString().trim();
    const opis = (mkb.opis || mkb.naziv || mkb.desc || "").toString().trim();
    const iz = mkb.izvor || {};
    const izvor = {
      sistem: (iz.sistem || iz.system || "ICD-10 / MKB-10").toString(),
      url: (iz.url || iz.URL || iz.link || "").toString(),
      autor: (iz.autor || "").toString(),
      delo: (iz.delo || "").toString(),
      licenca: (iz.licenca || "").toString()
    };
    return { code, opis, izvor };
  }

  _runtimeFreqToSTL(f, perMin = null) {
    if (!f) return null;
    const hz = Number(f.hz ?? f.value ?? 0);
    if (!Number.isFinite(hz) || hz <= 0) return null;

    const funkcija = (f.funkcija || f.svrha || f.desc || f.naziv || "").toString().trim();
    const opis = (f.opis || "").toString().trim();
    const naziv = (f.naziv || "").toString().trim();

    const izObj = f.izvor_obj || f.izvor || f.src || null;
    const izvor = this._sourceToObj(izObj);

    const out = {
      hz,
      naziv: naziv || "",
      opis: opis || "",
      funkcija: funkcija || "",
      izvor,
      enabled: f.enabled !== false
    };

    // Optional: keep per-frequency duration hint if known
    if (perMin !== null) out.trajanje_min = perMin;

    return out;
  }

  _sourceToObj(src) {
    const blank = { sistem: "", url: "", autor: "", delo: "", licenca: "" };
    if (!src) return { ...blank };

    if (typeof src === "string") {
      const s = src.trim();
      if (!s) return { ...blank };
      if (/^https?:\/\//i.test(s)) return { ...blank, url: s };
      return { ...blank, sistem: s };
    }

    if (typeof src !== "object") return { ...blank, sistem: String(src) };

    return {
      sistem: (src.sistem || src.system || src.tradicija || "").toString(),
      url: (src.url || src.URL || src.link || "").toString(),
      autor: (src.autor || "").toString(),
      delo: (src.delo || "").toString(),
      licenca: (src.licenca || "").toString()
    };
  }


  /* ===================== v15.3 — USER DATA (My Symptoms + Overrides) ===================== */

  async loadUserSymptoms() {
    try {
      const raw = localStorage.getItem("sinet_user_symptoms_v1");
      this.userSymptoms = raw ? JSON.parse(raw) : [];
      if (!Array.isArray(this.userSymptoms)) this.userSymptoms = [];
    } catch (e) {
      this.userSymptoms = [];
    }
  }

  async saveUserSymptoms() {
    try {
      localStorage.setItem("sinet_user_symptoms_v1", JSON.stringify(this.userSymptoms || []));
    } catch (e) {}
  }

  async loadOverrides() {
    try {
      const raw = localStorage.getItem("sinet_overrides_v1");
      this.overrides = raw ? JSON.parse(raw) : {};
      if (!this.overrides || typeof this.overrides !== "object") this.overrides = {};
    } catch (e) {
      this.overrides = {};
    }
  }

  async saveOverrides() {
    try { localStorage.setItem("sinet_overrides_v1", JSON.stringify(this.overrides || {})); } catch (e) {}
  }

  _deepMerge(base, patch) {
    if (Array.isArray(base) || Array.isArray(patch)) return patch; // replace arrays
    if (typeof base !== "object" || base === null) return patch;
    if (typeof patch !== "object" || patch === null) return patch;

    const out = { ...base };
    for (const k of Object.keys(patch)) {
      if (k in base) out[k] = this._deepMerge(base[k], patch[k]);
      else out[k] = patch[k];
    }
    return out;
  }

  applyUserDataToCatalog() {
    const core = Array.isArray(this.catalogCoreItems) ? this.catalogCoreItems.slice() : (this.catalogItems || []).slice();

    // Apply overrides to core
    let merged = core.map(it => {
      const ov = this.overrides?.[it.id];
      return ov ? this._deepMerge(it, ov) : it;
    });

    // Remove existing user items, then append latest
    merged = merged.filter(it => !String(it.id||"").startsWith("usr-"));
    const us = Array.isArray(this.userSymptoms) ? this.userSymptoms : [];
    merged = merged.concat(us);

    // De-duplicate by id
    const seen = new Set();
    const out = [];
    for (const it of merged) {
      const id = String(it?.id || "");
      if (!id) continue;
      if (seen.has(id)) continue;
      seen.add(id);
      out.push(it);
    }

    this.catalogItems = out;
  }

  renderUserSymptomsUI() {
    // refresh from storage in case it changed
    this.loadUserSymptoms().then(() => {
      this.applyUserDataToCatalog();
      this.renderUserSymptomsList();
    });
  }

  renderUserSymptomsList() {
    const box = this.ui.userSymptomsList || document.getElementById('user-symptoms-list');
    if (!box) return;

    const list = (this.userSymptoms || []);
    if (!list.length) {
      box.innerHTML = "<p style='text-align:center; color:#777;'>Još nema ličnih simptoma. Kliknite na dugme iznad da dodate. 🙂</p>";
      return;
    }

    box.innerHTML = list.map(it => {
      const short = (it.opis || "").toString().slice(0, 120);
      return `
        <div class="cat-item">
          <div class="cat-main" onclick="app.openModal('${it.id}')">
            <div class="cat-title">🧩 ${this.escapeHtml(it.simptom)}</div>
            <div class="cat-sub">${this.escapeHtml(short || "Klikni za detalje.")}</div>
          </div>
          <div class="cat-actions">
            <button class="cat-mini-btn" title="Izmeni" onclick="event.stopPropagation(); app.editUserSymptom('${it.id}')">✎ <span class="btn-label">Edit</span></button>
            <button class="cat-mini-btn" title="Obriši" onclick="event.stopPropagation(); app.deleteUserSymptom('${it.id}')">🗑</button>
          </div>
        </div>
      `;
    }).join("");
  }

  showUserSymptomForm(editId = null) {
    const host = this.ui.userSymptomForm || document.getElementById('user-symptom-form');
    if (!host) return;
    host.style.display = "block";

    const existing = editId ? (this.userSymptoms || []).find(x => x.id === editId) : null;

    const oblasts = Array.from(new Set((this.catalogItems || []).map(i => i.oblast).filter(Boolean))).sort();
    const oblastOptions = ['MOJI SIMPTOMI', ...oblasts].slice(0, 80)
      .map(o => `<option value="${this.escapeAttr(o)}"${(existing?.oblast||"MOJI SIMPTOMI")===o ? " selected":""}>${this.escapeHtml(o)}</option>`).join("");

    const freqs = Array.isArray(existing?.frekvencije) ? existing.frekvencije : [{hz:"", svrha:"", izvor:""}];

    const freqRows = freqs.map((f,i)=>`
      <div style="display:flex; gap:8px; margin:6px 0;">
        <input data-fhz="${i}" placeholder="Hz" value="${this.escapeAttr(f.hz ?? f.value ?? "")}" style="width:90px; padding:10px; border:1px solid #ddd; border-radius:8px;">
        <input data-fsv="${i}" placeholder="Šta radi / svrha" value="${this.escapeAttr(f.svrha || f.funkcija || "")}" style="flex:1; padding:10px; border:1px solid #ddd; border-radius:8px;">
      </div>
      <input data-fsrc="${i}" placeholder="Izvor (link ili tekst)" value="${this.escapeAttr(f.izvor || "")}" style="width:100%; padding:10px; border:1px solid #ddd; border-radius:8px; margin-bottom:6px;">
    `).join("");

    host.innerHTML = `
      <div style="background:#fff; border:1px solid #eee; border-radius:12px; padding:12px; margin-top:10px;">
        <div style="font-weight:900; margin-bottom:8px;">${existing ? "✎ Izmeni simptom" : "➕ Novi simptom"}</div>

        <label style="font-weight:900;">Naziv</label>
        <input id="us_name" value="${this.escapeAttr(existing?.simptom || "")}" placeholder="npr. Reumatoidni artritis" style="width:100%; padding:12px; border:1px solid #ddd; border-radius:8px; margin:6px 0 10px 0;">

        <label style="font-weight:900;">Oblast</label>
        <select id="us_oblast" style="width:100%; padding:12px; border:1px solid #ddd; border-radius:8px; margin:6px 0 10px 0;">
          ${oblastOptions}
        </select>

        <label style="font-weight:900;">Opis</label>
        <textarea id="us_desc" rows="3" placeholder="Kratko objašnjenje..." style="width:100%; padding:12px; border:1px solid #ddd; border-radius:8px; margin:6px 0 10px 0;">${this.escapeHtml(existing?.opis || "")}</textarea>

	        <button class="btn-full" style="margin-top:-2px; background:#3498db;" onclick="app.userSymptomToAI()">🤖 Dopuni preko AI (prompt)</button>
	        <p style="margin:8px 0 12px 0; color:#777; font-size:0.82rem;">
	          AI će napraviti kompletan STL JSON. Posle kopiranja prompta, zalepi AI odgovor u AI Upitnik i klikni „Uvezi u Moji simptomi“.
	        </p>

        <div style="display:flex; gap:10px;">
          <div style="flex:1;">
            <label style="font-weight:900;">MKB-10 (opciono)</label>
            <input id="us_mkb" value="${this.escapeAttr(existing?.mkb10 || "")}" placeholder="npr. M06.9" style="width:100%; padding:12px; border:1px solid #ddd; border-radius:8px; margin:6px 0 10px 0;">
          </div>
          <div style="flex:1;">
            <label style="font-weight:900;">Izvor (opciono)</label>
            <input id="us_src" value="${this.escapeAttr(existing?.izvor || "")}" placeholder="link ili tekst" style="width:100%; padding:12px; border:1px solid #ddd; border-radius:8px; margin:6px 0 10px 0;">
          </div>
        </div>

        <div style="font-weight:900; margin:8px 0;">Frekvencije</div>
        <div id="us_freqs">
          ${freqRows}
        </div>

        <div style="display:flex; gap:10px; margin-top:10px;">
          <button class="btn-full" style="flex:1; margin-top:0; background:#2ecc71;" onclick="app.addUserFreqRow()">➕ Dodaj frekvenciju</button>
          <button class="btn-full" style="flex:1; margin-top:0; background:#8e44ad;" onclick="app.saveUserSymptom('${existing?.id || ""}')">💾 Sačuvaj</button>
        </div>
        <button class="btn-full" style="margin-top:10px; background:#eee; color:#333;" onclick="app.cancelUserSymptomForm()">Zatvori</button>
      </div>
    `;
    this._userFormEditingId = existing?.id || null;
  }

  addUserFreqRow() {
    const box = document.getElementById('us_freqs');
    if (!box) return;
    const i = box.querySelectorAll('[data-fhz]').length;
    const row = document.createElement('div');
    row.innerHTML = `
      <div style="display:flex; gap:8px; margin:6px 0;">
        <input data-fhz="${i}" placeholder="Hz" value="" style="width:90px; padding:10px; border:1px solid #ddd; border-radius:8px;">
        <input data-fsv="${i}" placeholder="Šta radi / svrha" value="" style="flex:1; padding:10px; border:1px solid #ddd; border-radius:8px;">
      </div>
      <input data-fsrc="${i}" placeholder="Izvor (link ili tekst)" value="" style="width:100%; padding:10px; border:1px solid #ddd; border-radius:8px; margin-bottom:6px;">
    `;
    box.appendChild(row);
  }

  cancelUserSymptomForm() {
    const host = this.ui.userSymptomForm || document.getElementById('user-symptom-form');
    if (host) { host.style.display = "none"; host.innerHTML = ""; }
    this._userFormEditingId = null;
  }

  _slugify(name) {
    return this._norm(name).replace(/\s+/g, '-').replace(/-+/g,'-').replace(/^-|-$/g,'') || "symptom";
  }

  async saveUserSymptom(existingId = "") {
    try {
      const name = document.getElementById('us_name')?.value?.trim();
      if (!name) return alert("Unesite naziv simptoma.");
      const oblast = document.getElementById('us_oblast')?.value || "MOJI SIMPTOMI";
      const desc = document.getElementById('us_desc')?.value || "";
      const mkb10 = document.getElementById('us_mkb')?.value?.trim() || "";
      const src = document.getElementById('us_src')?.value?.trim() || "";

      // collect freqs
      const hzInputs = Array.from(document.querySelectorAll('[data-fhz]'));
      const freqs = hzInputs.map(inp => {
        const i = inp.getAttribute('data-fhz');
        const hz = inp.value?.trim();
        const svrha = document.querySelector(`[data-fsv="${i}"]`)?.value?.trim() || "";
        const izvor = document.querySelector(`[data-fsrc="${i}"]`)?.value?.trim() || "";
        if (!hz && !svrha && !izvor) return null;
        return { hz: hz ? Number(hz) : "", svrha, izvor };
      }).filter(Boolean);

      let id = existingId || ("usr-" + this._slugify(name));
      if (!existingId) {
        // ensure unique
        const used = new Set((this.userSymptoms || []).map(x => x.id));
        if (used.has(id)) {
          let k = 2;
          while (used.has(`${id}-${k}`)) k++;
          id = `${id}-${k}`;
        }
      }

      const item = {
        id,
        simptom: name,
        oblast,
        opis: desc,
        mkb10,
        izvor: src,
        frekvencije: freqs
      };

      const list = Array.isArray(this.userSymptoms) ? this.userSymptoms : [];
      const ix = list.findIndex(x => x.id === id || (existingId && x.id === existingId));
      if (ix >= 0) list[ix] = item;
      else list.unshift(item);
      this.userSymptoms = list;

      await this.saveUserSymptoms();
      this.applyUserDataToCatalog();
      this.renderUserSymptomsList();
      this.cancelUserSymptomForm();
      alert("Sačuvano ✅");

      // refresh presets/catalog if needed
      this.renderSystemPresets();
      if (document.getElementById('page-catalog')?.classList?.contains('active')) this.showCatalogHome();
    } catch (e) {
      alert("Greška: " + (e?.message || e));
    }
  }

  editUserSymptom(id) {
    this.nav('mysymptoms');
    this.showUserSymptomForm(id);
  }

  async deleteUserSymptom(id) {
    if (!confirm("Obrisati ovaj simptom?")) return;
    this.userSymptoms = (this.userSymptoms || []).filter(x => x.id !== id);
    await this.saveUserSymptoms();
    this.applyUserDataToCatalog();
    this.renderUserSymptomsList();
    this.renderSystemPresets();
    if (document.getElementById('page-catalog')?.classList?.contains('active')) this.showCatalogHome();
  }

  /* ===================== v15.3 — MODAL ADVANCED (JSON / overrides) ===================== */

  renderModalAdvanced(item) {
    const host = document.getElementById('m-advanced');
    if (!host) return;
    const base = item || this._modalItem;
    if (!base) { host.innerHTML = ""; return; }

    const existing = this.overrides?.[base.id];
    const json = JSON.stringify(existing ? this._deepMerge(base, existing) : base, null, 2);

    host.innerHTML = `
      <div style="background:#fff; border:1px solid #eee; border-radius:12px; padding:12px;">
        <div style="color:#666; margin-bottom:8px;">
          Ovde vidiš ceo slog (JSON). Možeš da napraviš lokalnu izmenu (override) bez menjanja kataloga.
        </div>
        <textarea id="m-adv-json" rows="8" style="width:100%; padding:10px; border:1px solid #ddd; border-radius:10px;">${this.escapeHtml(json)}</textarea>

        <div style="display:flex; gap:10px; margin-top:10px;">
          <button class="btn-full" style="flex:1; margin-top:0; background:#2ecc71;" onclick="app.copyModalJSON()">📋 Kopiraj</button>
          <button class="btn-full" style="flex:1; margin-top:0; background:#8e44ad;" onclick="app.saveModalOverride()">💾 Sačuvaj override</button>
        </div>
        <button class="btn-full" style="margin-top:10px; background:#eee; color:#333;" onclick="app.clearModalOverride()">♻ Vrati original</button>
      </div>
    `;
  }

  copyModalJSON() {
    const ta = document.getElementById('m-adv-json');
    if (!ta) return;
    ta.select();
    document.execCommand('copy');
    alert("Kopirano ✅");
  }

  async saveModalOverride() {
    try {
      const ta = document.getElementById('m-adv-json');
      if (!ta || !this._modalItem?.id) return;
      const patch = JSON.parse(ta.value);
      this.overrides = this.overrides || {};
      this.overrides[this._modalItem.id] = patch;
      await this.saveOverrides();
      this.applyUserDataToCatalog();
      alert("Override sačuvan ✅ (lokalno)");
    } catch (e) {
      alert("Neispravan JSON: " + (e?.message || e));
    }
  }

  async clearModalOverride() {
    if (!this._modalItem?.id) return;
    if (!confirm("Obrisati lokalni override i vratiti original?")) return;
    if (this.overrides) delete this.overrides[this._modalItem.id];
    await this.saveOverrides();
    this.applyUserDataToCatalog();
    this.renderModalAdvanced(this._modalItem);
    alert("Vraćeno ✅");
  }

  /* ===================== v15.3 — AI UPITNIK (prompt generator) ===================== */

  prepareAIUI() {
    // no-op for now; kept for future expansions
  }

  prefillAI(symptom = "", desc = "", note = "") {
    try {
      const s = document.getElementById('ai_symptom');
      const d = document.getElementById('ai_desc');
      if (s && symptom) s.value = symptom;
      if (d && desc) d.value = desc;
      if (note) console.log("AI note:", note);
    } catch (_) {}
  }

  userSymptomToAI() {
    const name = (document.getElementById('us_name')?.value || "").trim();
    const desc = (document.getElementById('us_desc')?.value || "").trim();
    if (!name) return alert("Prvo upiši naziv simptoma.");
    this.prefillAI(name, desc);
    this.nav('ai');
    // Auto-generate prompt for convenience
    setTimeout(() => this.generateAIPrompt(), 50);
  }

  generateAIPrompt() {
    const symptom = (document.getElementById('ai_symptom')?.value || "").trim();
    const desc = (document.getElementById('ai_desc')?.value || "").trim();
    const age = (document.getElementById('ai_age')?.value || "").trim();
    const sex = (document.getElementById('ai_sex')?.value || "nebitno").trim();
    const med = (document.getElementById('ai_med')?.value || "").trim();
    const goal = (document.getElementById('ai_goal')?.value || "").trim();

    if (!symptom) return alert("Upiši simptom / problem.");

    const prompt = `
TI SI medicinsko-informativni asistent za SINET Audio Lekar.
Tvoja uloga je da napraviš JEDAN slog simptoma u SINET STL v1.1 formatu (offline katalog), sa proverljivim izvorima.
NE DIJAGNOSTIKUJ; NE DAVAJ hitne medicinske savete. Ako uočiš alarmantne simptome, u JSON dodaj kratku napomenu u polju "napomena" da korisnik potraži lekara.

Korisnički unos:
- Simptom: "${symptom}"
- Opis: "${desc}"
- Godine: "${age}"
- Pol: "${sex}"
- Dijagnoze/terapije/napomene: "${med}"
- Cilj: "${goal}"

ZADATAK:
1) Vrati VALIDAN JSON (bez markdown-a, bez dodatnog teksta).
2) Popuni sledeća polja (što detaljnije, ali kratko i jasno za starije osobe):
   - id (slug, latinica, bez razmaka)
   - uid: null
   - naziv
   - opis
   - mkb10: { sifra, naziv/opis, izvor: { sistem, url } }  (ako nema URL — navedi naziv sistema)
   - psihosomatika: { uzrok, lek, izvor: { autor, delo, url } }
   - afirmacija: { tekst, autor, izvor: { autor, delo, url, napomena } }
   - molitva: { tekst, izvor: { tradicija, url } }
   - narodni_lek: { opis/tekst, napomena, izvor: { autor, delo, url } }
   - akupresura: [ { tacka, naziv, lokacija, uputstvo, izvor: { sistem, url } } ]  (3–6 tačaka)
   - frekvencije: [ { hz, naziv, opis, funkcija, izvor: { sistem, autor, delo, url, licenca } } ] (8–15 frekvencija)
3) SVAKO polje koje ima "izvor" mora imati proverljiv izvor (URL ili autor+delo).
4) Izlazni JSON format:
{
  "stl_version": "1.1",
  "napomena": "...(opciono)...",
  "simptom": {
    ... polja iznad ...
  }
}

VAŽNO: samo JSON.`;

    const out = document.getElementById('ai_prompt');
    if (out) out.value = prompt.trim();
  }

  copyAIPrompt() {
    const out = document.getElementById('ai_prompt');
    if (!out) return;
    out.select();
    document.execCommand('copy');
    alert("Prompt kopiran ✅");
  }

  /* ===== v15.4 — AI JSON import into My Symptoms ===== */
  _mkbToText(mkb) {
    if (!mkb) return "";
    if (typeof mkb === 'string') return mkb;
    const code = (mkb.sifra || mkb.code || "").toString().trim();
    const name = (mkb.naziv || mkb.opis || "").toString().trim();
    if (code && name) return `${code} — ${name}`;
    return code || name || "";
  }

  _srcToText(src) {
    if (!src) return "";
    if (typeof src === 'string') return src;
    const url = (src.url || "").toString().trim();
    if (url) return url;
    const delo = (src.delo || "").toString().trim();
    const autor = (src.autor || "").toString().trim();
    if (delo && autor) return `${delo} — ${autor}`;
    return delo || autor || (src.sistem || "") || "";
  }

  async importAIResult() {
    const raw = (document.getElementById('ai_result')?.value || "").trim();
    if (!raw) return alert("Zalepi AI odgovor (JSON) u polje ispod.");

    let obj;
    try {
      obj = JSON.parse(raw);
    } catch (e) {
      return alert("Ne mogu da pročitam JSON. Proveri da AI nije vratio markdown ili dodatni tekst.");
    }

    const s = obj?.simptom || obj?.symptom || obj;
    if (!s || typeof s !== 'object') return alert("JSON nema polje 'simptom'.");

    const naziv = (s.naziv || s.name || s.simptom || "").toString().trim();
    if (!naziv) return alert("Nedostaje 'naziv' u simptomu.");
    const opis = (s.opis || "").toString();

    const slug = (s.id || this._slugify(naziv)).toString().trim().replace(/^usr-/, '');
    let id = `usr-${slug}`;

    // Avoid collisions
    const used = new Set((this.userSymptoms || []).map(x => x.id));
    if (!used.has(id)) {
      // ok
    } else {
      let k = 2;
      while (used.has(`${id}-${k}`)) k++;
      id = `${id}-${k}`;
    }

    // Frequencies
    const freqsIn = Array.isArray(s.frekvencije) ? s.frekvencije : [];
    const freqs = freqsIn.map((f) => {
      const hz = Number(f?.hz ?? f?.value ?? 0) || 0;
      if (!hz) return null;
      const svrha = (f?.funkcija || f?.svrha || f?.opis || f?.naziv || "").toString();
      const izvor = this._srcToText(f?.izvor);
      return { hz, value: hz, svrha, izvor, enabled: f?.enabled !== false };
    }).filter(Boolean);

    const mkb10 = this._mkbToText(s.mkb10);

    const holisticki = {
      psihosomatika: s.psihosomatika || null,
      afirmacija: s.afirmacija || null,
      molitva: s.molitva || null,
      narodni_lek: s.narodni_lek || null
    };

    // Acupressure: allow array/object
    let akup = s.akupresura;
    if (akup && !Array.isArray(akup) && typeof akup === 'object') akup = [akup];
    if (!Array.isArray(akup)) akup = [];
    akup = akup.map(p => ({
      tacka: p.tacka || p.point || "",
      naziv: p.naziv || "",
      lokacija: p.lokacija || "",
      uputstvo: p.uputstvo || p.how || "",
      slika: p.slika,
      marker: p.marker,
      izvor: this._srcToText(p.izvor)
    })).filter(p => p.tacka || p.naziv || p.lokacija || p.uputstvo);

    const item = {
      id,
      simptom: naziv,
      oblast: "MOJI SIMPTOMI",
      opis,
      mkb10,
      holisticki,
      akupresura: akup,
      frekvencije: freqs
    };

    const list = Array.isArray(this.userSymptoms) ? this.userSymptoms : [];
    list.unshift(item);
    this.userSymptoms = list;
    await this.saveUserSymptoms();
    this.applyUserDataToCatalog();
    this.renderUserSymptomsList();
    this.renderSystemPresets();

    alert("Uvezeno u 'Moji simptomi' ✅");
    this.nav('mysymptoms');
    setTimeout(() => this.openModal(id), 50);
  }
  /* ===================== UTIL ===================== */

  escapeHtml(str) {
    return (str || "").toString()
      .replace(/&/g, "&amp;")
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;")
      .replace(/\"/g, "&quot;")
      .replace(/'/g, "&#39;");
  }

  escapeAttr(str) {
    // attribute-safe (already escapes quotes)
    return this.escapeHtml(str);
  }

  getMKB10Code(mkb10) {
    if (!mkb10) return "";
    if (typeof mkb10 === "string") {
      const s = mkb10.trim();
      if (!s) return "";
      // Prefer first token that looks like a code (e.g., M06.9)
      const m = s.match(/[A-Z][0-9]{2}(?:\.[0-9])?/i);
      return (m ? m[0] : s.split(/[\s—-]/)[0]).trim();
    }
    const code = (mkb10.code || mkb10.sifra || mkb10.sifra_mkb || "").toString().trim();
    return code;
  }

  getMKB10Desc(mkb10) {
    if (!mkb10 || typeof mkb10 === "string") return "";
    const d = (mkb10.opis || mkb10.naziv || mkb10.description || "").toString().trim();
    return d;
  }


  getMKB10Url(mkb10) {
    if (!mkb10 || typeof mkb10 !== "object") return "";
    const u = (mkb10?.izvor?.url || mkb10?.source?.url || mkb10?.izvor_url || "").toString().trim();
    return u;
  }

  
  formatMKB10Html(mkb10, opts = {}) {
    const includeLink = opts.includeLink !== false;
    const showEmpty = opts.showEmpty === true;

    const empty = showEmpty ? `<span class="muted">nije popunjeno</span>` : "";
    if (!mkb10) return empty;

    if (typeof mkb10 === "string") {
      const s = mkb10.trim();
      return s ? this.escapeHtml(s) : empty;
    }

    const code = this.getMKB10Code(mkb10);
    const desc = this.getMKB10Desc(mkb10);
    const sys = (mkb10?.izvor?.sistem || mkb10?.izvor?.system || "").toString().trim();
    const url = this.getMKB10Url(mkb10);

    const main = (code && desc)
      ? `${this.escapeHtml(code)} — ${this.escapeHtml(desc)}`
      : this.escapeHtml(code || desc);

    if (!main) return empty;

    let html = main;
    if (sys) html += ` <span class="muted" style="font-size:0.85rem; color:#666;">(${this.escapeHtml(sys)})</span>`;
    if (includeLink && url) {
      html += `<div class="muted" style="margin-top:6px; font-size:0.85rem; color:#666;">🔗 <a href="${this.escapeAttr(url)}" target="_blank" rel="noopener noreferrer">Izvor MKB-10</a></div>`;
    }
    return html;
  }


  // Backward-compatible wrapper name (used across UI)
  formatMKB10(mkb10){
    return this.formatMKB10Html(mkb10);
  }

  setModalFreqEnabled(index, enabled){
    const i = Number(index);
    if(!Number.isFinite(i)) return;
    if(!this._modalItem || !this._modalItem.frekvencije || !this._modalItem.frekvencije[i]) return;
    this._modalItem.frekvencije[i].enabled = !!enabled;

    // live update modal totals
    const enabledCount = (this._modalItem.frekvencije || []).filter(f=>f.enabled!==false).length;
    const estMin = enabledCount * (Number(this._modalItem.freq_duration_min)||0);
    const el = document.getElementById("m-proto");
    if(el){
      const loops = Number(this._modalItem.freq_loops)||1;
      const totalMin = estMin * loops;
      el.textContent = `${enabledCount} frekv. • ${this._modalItem.freq_duration_min} min x ${loops} = ~${totalMin} min`;
    }
  }

  toggleNowList(){
    if(!this.ui.nowPlayingPanel) return;
    const open = this.ui.nowPlayingPanel.style.display !== "none";
    this.ui.nowPlayingPanel.style.display = open ? "none" : "block";

    // Jasno dugme (da ne izgleda kao "belo ništa")
    const btnNowList = document.getElementById('btn-nowlist');
    if (btnNowList) {
      btnNowList.innerHTML = open ? '▸ FREKVENCIJE' : '▾ FREKVENCIJE';
      btnNowList.setAttribute('aria-expanded', (!open).toString());
    }

    // Render list when opening (esp. iOS PRO Render mode uses fullSequence)
    if(!open) this.renderNowPlayingList();
  }


  /* ===== v15.7.1.5 — Dock Loop controls ===== */

  toggleDockLoopPanel(){
    const panel = document.getElementById('dock-loop-panel');
    const btn = document.getElementById('btn-dock-loop');
    if(!panel || !btn) return;

    const open = panel.style.display !== 'none';
    panel.style.display = open ? 'none' : 'block';
    btn.setAttribute('aria-expanded', (!open).toString());

    if(!open) this._syncRepeatControlsFromState('dock');
  }

  _syncRepeatControlsFromState(ctx){
    const s = { count: this.repeat?.count || 1, infinite: !!this.repeat?.infinite, scope: this.repeat?.scope || REPEAT_SCOPE_ITEM };
    this._setRepeatControls(ctx, s);
  }

  _setRepeatControls(ctx, s){
    // ctx: 'dock' | 'playlist' | 'modal'
    const isModal = (ctx === 'modal');
    const isDock = (ctx === 'dock');

    const idCount = isModal ? 'm-repeat-count' : (isDock ? 'p-repeat-count' : 'pl-repeat-count');
    const idInf = isModal ? 'm-repeat-infinite' : (isDock ? 'p-repeat-infinite' : 'pl-repeat-infinite');
    const nameScope = isModal ? 'm-repeat-scope' : (isDock ? 'p-repeat-scope' : 'pl-repeat-scope');

    try {
      const elC = document.getElementById(idCount);
      if (elC) elC.value = String(Math.max(1, Math.min(200, Number(s?.count) || 1)));
    } catch(_) {}

    try {
      const elI = document.getElementById(idInf);
      if (elI) elI.checked = !!s?.infinite;
    } catch(_) {}

    try {
      const scope = (s?.scope === REPEAT_SCOPE_QUEUE) ? REPEAT_SCOPE_QUEUE : REPEAT_SCOPE_ITEM;
      const el = document.querySelector(`input[name="${nameScope}"][value="${scope}"]`);
      if (el) el.checked = true;
    } catch(_) {}
  }

  onDockRepeatChange(){
    const s = this._readRepeatSettings('dock');
    this._applyRepeatSettings(s);

    // Keep other UIs in sync
    this._setRepeatControls('playlist', s);
    this._setRepeatControls('modal', s);

    // Persist
    try { localStorage.setItem('sinet_repeat_settings', JSON.stringify(s)); } catch(_) {}

    try { this._renderRepeatStatus(); } catch(_) {}

    try {
      if (this.isPlaying && this.isPlaying()) {
        this.showToast('🔁 Loop podešen. Važi odmah (najkasnije od sledećeg ciklusa).', { timeoutMs: 3500 });
      }
    } catch(_) {}
  }

  _restoreRepeatFromStorage(){
    try {
      const raw = localStorage.getItem('sinet_repeat_settings');
      if (!raw) return;
      const s = JSON.parse(raw);
      if (!s) return;

      this._applyRepeatSettings(s);
      this._setRepeatControls('dock', s);
      this._setRepeatControls('playlist', s);
      this._setRepeatControls('modal', s);
    } catch(_) {}
  }

  toggleFreqEnabled(index, enabled){
    const i = Number(index);
    if(!Number.isFinite(i)) return;
    if(!this.audio || !this.audio.currentSequence) return;

    this.audio.setEnabled(i, !!enabled);

    const stats = this.audio.getStats ? this.audio.getStats() : (this.audio.getState ? this.audio.getState() : null);
    if(stats && stats.currentIndex === i && !enabled){
      this.audio.skipCurrent();
    }
    this.renderNowPlayingList();
  }

  renderNowPlayingList(statsOverride=null){
    if(!this.ui.nowPlayingList) return;

    // iOS PRO (Rendered Segments): audio.currentSequence is not used → show list from rendered fullSequence.
    if((!this.audio || !this.audio.currentSequence) && this._rendered && this._rendered.active){
      const seqFull = this._rendered.fullSequence || this._rendered.sequence || [];
      const stats = statsOverride || this._lastStats || { currentIndex: Number(this._rendered.segStartIndex||0) };
      const cur = Math.max(0, Math.min(seqFull.length-1, Number(stats.currentIndex||0)));

      try {
        const hintEl = document.getElementById('nowplaying-hint');
        if (hintEl) hintEl.textContent = '🍏 iOS PRO (Render): lista je pregled. Preskakanje se primenjuje od sledećeg segmenta.';
      } catch(_) {}

      let html = "";
      for(let i=cur;i<seqFull.length;i++){
        const f = seqFull[i] || {};
        const hz = f.hz ?? f.value ?? "";
        const desc = (f.svrha || f.funkcija || f.desc || f.note || "").toString();
        const src = (f.izvor || f.src || "").toString();
        html += `
          <div class="np-row ${i===cur ? "active" : ""}" id="rfreq_${i}">
            <label>
              <input type="checkbox" checked disabled>
              <div>
                <div><b>${hz} Hz</b></div>
                ${desc ? `<div class="muted">${desc}</div>` : ""}
                ${src ? `<div class="muted">Izvor: ${src}</div>` : ""}
              </div>
            </label>
          </div>`;
      }
      this.ui.nowPlayingList.innerHTML = html || '<div class="muted" style="opacity:0.9; padding:8px;">Nema preostalih frekvencija.</div>';
      return;
    }

    if(!this.audio || !this.audio.currentSequence){
      try { const hintEl = document.getElementById('nowplaying-hint'); if (hintEl) hintEl.textContent = 'Odčekiraj da preskočiš (može i tokom rada).'; } catch(_) {}
      this.ui.nowPlayingList.innerHTML = "";
      return;
    }

    try { const hintEl = document.getElementById('nowplaying-hint'); if (hintEl) hintEl.textContent = 'Odčekiraj da preskočiš (može i tokom rada).'; } catch(_) {}
    const stats = statsOverride || (this.audio.getStats ? this.audio.getStats() : {currentIndex:0});
    const seq = this.audio.currentSequence || [];
    const cur = Number(stats.currentIndex||0);

    let html = "";
    for(let i=cur;i<seq.length;i++){
      const f = seq[i] || {};
      const hz = f.hz ?? f.value ?? "";
      const desc = (f.svrha || f.funkcija || f.desc || f.note || "").toString();
      const src = (f.izvor || f.src || "").toString();
      const enabled = this.audio.isEnabled ? this.audio.isEnabled(i) : true;
      html += `
        <div class="np-row ${i===cur ? "active" : ""} ${enabled ? "" : "disabled"}" id="freq_${i}">
          <label>
            <input type="checkbox" ${enabled ? "checked" : ""} onchange="window.app.toggleFreqEnabled(${i}, this.checked)">
            <div>
              <div><b>${hz} Hz</b></div>
              ${desc ? `<div class="muted">${desc}</div>` : ""}
              ${src ? `<div class="muted">Izvor: ${src}</div>` : ""}
            </div>
          </label>
        </div>`;
    }
    this.ui.nowPlayingList.innerHTML = html;
  }


  
  // iOS setting: experimental background mode (best-effort only)
  isIosBgExperimentalEnabled() { return !!this._iosBgExperimental; }

  setIosBgExperimental(enabled) {
    const val = !!enabled;
    this._iosBgExperimental = val;
    try { localStorage.setItem("sinet_ios_bg_experimental", val ? "1" : "0"); } catch(_) {}
    try { if (this._iosKeeper) this._iosKeeper.enabled = (this._isIOS && (val || this._iosBgRendered)); } catch(_) {}

    // If experimental is ON, force-disable PRO rendered mode (avoid conflicts)
    if (val && this._iosBgRendered) {
      this._iosBgRendered = false;
      try { localStorage.setItem("sinet_ios_bg_rendered", "0"); } catch(_) {}
      try { const el2 = document.getElementById("ios-bg-render-toggle"); if (el2) el2.checked = false; } catch(_) {}
    }

    // keeper enabled follows the final effective state
    try { if (this._iosKeeper) this._iosKeeper.enabled = (this._isIOS && (this._iosBgExperimental || this._iosBgRendered)); } catch(_) {}


    // If playing, re-apply routing immediately
    try {
      if (this.audio && this.audio.isPlaying) {
        this._teardownPlaybackSession("ios_toggle");
        this._ensurePlaybackSession();
      }
    } catch(_) {}

    try {
      const el = document.getElementById("ios-bg-toggle");
      if (el) el.checked = val;
    } catch(_) {}

    this.showToast(val
      ? "🍏 iOS: pozadinski zvuk uključen (eksperimentalno). Ako čuješ pulsiranje, isključi opciju."
      : "🍏 iOS: pozadinski zvuk isključen (stabilno). U pozadini će se pauzirati.",
      { timeoutMs: 6500 }
    );
  }


  setIosBgRendered(enabled) {
    const val = !!enabled;
    this._iosBgRendered = val;
    try { localStorage.setItem("sinet_ios_bg_rendered", val ? "1" : "0"); } catch(_) {}

    // keeper enabled follows rendered/experimental state
    try { if (this._iosKeeper) this._iosKeeper.enabled = (this._isIOS && (val || this._iosBgExperimental)); } catch(_) {}

    // If rendered is ON, force-disable experimental MediaStream route (avoid pulsing conflicts)
    if (val && this._iosBgExperimental) {
      this._iosBgExperimental = false;
      try { localStorage.setItem("sinet_ios_bg_experimental", "0"); } catch(_) {}
      try { const el = document.getElementById("ios-bg-toggle"); if (el) el.checked = false; } catch(_) {}
    }

    // keeper enabled follows the final effective state
    try { if (this._iosKeeper) this._iosKeeper.enabled = (this._isIOS && (this._iosBgExperimental || this._iosBgRendered)); } catch(_) {}

    // Update UI checkbox
    try {
      const el2 = document.getElementById("ios-bg-render-toggle");
      if (el2) el2.checked = val;
    } catch(_) {}

    // If playing, re-apply routing immediately
    try {
      if (this.audio && (this.audio.isPlaying || this._isRenderedPlaying?.())) {
        this._teardownPlaybackSession("ios_render_toggle");
        this._ensurePlaybackSession();
      }
    } catch(_) {}

    this.showToast(enabled
      ? "🍏 iOS: PRO režim uključen — protokol se renderuje u WAV (RAM) i može da nastavi u pozadini (web-only, bez garancije)."
      : "🍏 iOS: PRO režim isključen.",
      { timeoutMs: 8000 }
    );
  }

  // v15.7.1.5: Bugfix — v15.6.8 referenced isIosBgRenderedEnabled() in several
  // places (playback start / settings), but the method was missing. On iPhone
  // this throws and prevents the "Play frekvencije" panel from opening.
  isIosBgRenderedEnabled() {
    return !!this._iosBgRendered;
  }

  // Defensive alias (mixed naming in older patches)
  isIOSBgRenderedEnabled() {
    return this.isIosBgRenderedEnabled();
  }

/* ===================== iOS / Background Hardening ===================== */

  _ensurePlaybackSession() {
    // iOS: browsers are sandboxed; background/lock-screen playback is NOT guaranteed.
    // Default behavior (stable): pause when app goes to background.
    // Optional (experimental): route WebAudio output through HTMLMediaElement (MediaStream).
    if (this._isIOS) {
      const exp = this.isIosBgExperimentalEnabled();
      const pro = this.isIosBgRenderedEnabled();

      // iOS: unlock / keep audio session alive via a silent HTMLAudio loop.
      // IMPORTANT: must be started from a user gesture at least once.
      try {
        if ((exp || pro) && this._iosKeeper) {
          this._iosKeeper.enabled = true;
          this._iosKeeper.start();
        } else if (this._iosKeeper) {
          this._iosKeeper.stop();
        }
      } catch(_) {}

// Prime hidden media elements (per-element unlock on iOS can be strict).
// We prime with SILENT_WAV to avoid audible noise, but it still counts as a user-initiated play.
try {
  if (pro) {
    const el = this._ensureIosRenderedEl();
    if (el && el.paused) {
      el.src = SILENT_WAV_DATA_URI;
      el.loop = true;
      el.preload = "auto";
      el.playsInline = true;
      el.setAttribute && el.setAttribute("playsinline", "");
      el.volume = 0.0001;
      el.muted = false;
      const pr = el.play();
      if (pr && pr.catch) pr.catch(()=>{});
    }
  } else if (exp && !pro) {
    const el2 = this._ensureIosMediaOutEl();
    if (el2 && el2.paused) {
      el2.src = SILENT_WAV_DATA_URI;
      el2.loop = true;
      el2.preload = "auto";
      el2.playsInline = true;
      el2.setAttribute && el2.setAttribute("playsinline", "");
      el2.volume = 0.0001;
      el2.muted = false;
      const pm = el2.play();
      if (pm && pm.catch) pm.catch(()=>{});
    }
  }
} catch(_) {}

      // Configure output routing
      try {
        if (this.audio && typeof this.audio.disableMediaOutput === "function") {
          this.audio.disableMediaOutput();
        }
        if (exp && !pro && this.audio && typeof this.audio.enableMediaOutput === "function") {
          const outEl = this._ensureIosMediaOutEl();
          this.audio.enableMediaOutput(outEl);
        }
      } catch(_) {}

      // One-time UX hint (dismissible)
      try {
        const dismissed = localStorage.getItem("sinet_ios_bg_hint") === "1";
        if (!dismissed && !this._iosHintShown) {
          this._iosHintShown = true;
          this.showToast(
            exp
              ? "🍏 iOS (eksperimentalno): u pozadini može doći do pulsiranja ili prekida. Ako smeta, isključi opciju u Podešavanjima."
              : "🍏 iOS: Safari uglavnom pauzira zvuk u pozadini/na lock-screen. Ovo je stabilan režim.",
            {
              timeoutMs: 9000,
              actionLabel: "Ne prikazuj više",
              action2Onclick: "localStorage.setItem('sinet_ios_bg_hint','1')"
            }
          );
        }
      } catch(_) {}
    }

    // Keep AudioContext resumed while playing (best-effort)
    if (this._ctxHeartbeat) return;
    this._ctxHeartbeat = setInterval(() => {
      this._resumeAudioContextBestEffort();
    }, 1500);
  }

  _teardownPlaybackSession(reason="") {
    if (this._ctxHeartbeat) {
      clearInterval(this._ctxHeartbeat);
      this._ctxHeartbeat = null;
    }

    // Always stop iOS helper elements; keep routing clean between sessions
    // iOS PRO: stop rendered track if any
    try { if (this._rendered && this._rendered.active) this._stopRenderedTrack(); } catch(_) {}
    try { if (this._iosKeeper) this._iosKeeper.stop(); } catch(_) {}
    try { if (this.audio && typeof this.audio.disableMediaOutput === "function") this.audio.disableMediaOutput(); } catch(_) {}
    try {
      if (this._iosMediaOutEl) {
        this._iosMediaOutEl.pause?.();
        try { this._iosMediaOutEl.srcObject = null; } catch(_) {}
      }
    } catch(_) {}
  }

  _resumeAudioContextBestEffort() {
    try {
      const ctx = this.audio?.audioContext || null;
      if (ctx && ctx.state === "suspended") {
        ctx.resume().catch(() => {});
      }
    } catch(_) {}
  }

  _bindBackgroundRecovery() {
    // When page becomes visible again, try to resume context (some iOS builds suspend it).
    const kick = () => this._resumeAudioContextBestEffort();

    document.addEventListener("visibilitychange", () => {
      // iOS stable policy: pause on background to avoid glitches/pulsing and forced stop after a few seconds.
      if (document.hidden) {
        try {
          if (this._isIOS && (this.audio?.isPlaying || this._rendered?.active) && !this.isIosBgExperimentalEnabled() && !this.isIosBgRenderedEnabled()) {
            this.togglePlayPause(); // pause
            this.showToast("🍏 iOS: zvuk je pauziran u pozadini (Safari ograničenje). Vrati se u aplikaciju i tapni ▶ za nastavak.", { timeoutMs: 9000 });
          }
        } catch(_) {}
        return;
      }
      kick();
    });

    window.addEventListener("pageshow", kick);
    window.addEventListener("focus", kick);
    window.addEventListener("resume", kick);
  }

  _setupMediaSession() {
    try {
      if (!("mediaSession" in navigator)) return;
      const ms = navigator.mediaSession;

      const safe = (fn) => () => { try { fn(); } catch(_) {} };

      ms.setActionHandler?.("play", safe(() => {
        if (!this.audio.isPlaying) this.togglePlayPause();
      }));
      ms.setActionHandler?.("pause", safe(() => {
        if (this.audio.isPlaying) this.togglePlayPause();
      }));
      ms.setActionHandler?.("stop", safe(() => {
        this.stopPlayer(true);
      }));
      ms.setActionHandler?.("previoustrack", safe(() => {
        if (this.isPlaylistActive) this.playPlaylistItem(Math.max(0, this.currentPlaylistIndex - 1));
      }));
      ms.setActionHandler?.("nexttrack", safe(() => {
        if (this.isPlaylistActive) this.playPlaylistItem(this.currentPlaylistIndex + 1);
      }));

      this._mediaSessionReady = true;
    } catch(_) {
      this._mediaSessionReady = false;
    }
  }

  _updateMediaSessionMetadata(freqObj, stats) {
    if (!this._mediaSessionReady) return;
    try {
      const hz = Number(freqObj?.value ?? freqObj?.hz) || 0;
      const symptom = (this.selectedItem?.simptom || "SINET Terapija").toString();
      const pos = (Number(stats?.currentIndex) || 0) + 1;
      const total = Number(stats?.totalItems) || 0;

      const title = hz ? `${hz} Hz  (${pos}/${total})` : `SINET Terapija (${pos}/${total})`;
      const artist = "SINET Audio Lekar";
      const album = symptom;

      navigator.mediaSession.metadata = new MediaMetadata({
        title,
        artist,
        album
      });
    } catch(_) {}
  }

  formatTime(sec) {
    const n = Number(sec);
    if (!Number.isFinite(n)) return '∞';
    const s = Math.max(0, Math.floor(n||0));
    const m = Math.floor(s/60);
    const r = s%60;
    return `${m}:${r<10 ? "0"+r : r}`;
  }
}

const app = new App();


// === DS Generator integration (safe global hooks) ===
window.openDSGenerator = function(){
  try{
    const a = window.app;
    const itemId = (a && a.selectedItem && a.selectedItem.id) ? a.selectedItem.id : '';
    const back = encodeURIComponent(window.location.href);
    const url = `DS-Generator.html?catalog=/data/SINET_STL.json${itemId ? `&freqId=${encodeURIComponent(itemId)}` : ''}&back=${back}`;
    window.open(url, '_blank');
  }catch(e){
    console.warn('openDSGenerator failed', e);
    window.open('DS-Generator.html?catalog=/data/SINET_STL.json', '_blank');
  }
};

async function __importDsBridgeIfAny(){
  try{
    const raw = localStorage.getItem('SINET_DS_BRIDGE');
    if(!raw) return false;

    const payload = JSON.parse(raw);
    if(!payload || payload.format !== 'SINET_DS_TO_PROTOCOL_v1' || !payload.protocol) return false;

    const p0 = payload.protocol;
    if(!p0 || typeof p0 !== 'object' || !Array.isArray(p0.steps) || p0.steps.length===0){
      localStorage.removeItem('SINET_DS_BRIDGE');
      window.app?.showToast?.('⚠️ DS Generator: protokol je prazan ili neispravan.', {timeoutMs: 9000});
      return false;
    }

    const a = window.app;
    if(!a) return false;

    // Ensure db exists
    if(!a.db && window.db) a.db = window.db;

    const p = JSON.parse(JSON.stringify(p0));
    if(!p.id) p.id = a._newProtoId?.() || (`DS_${Date.now()}`);
    if(!p.name) p.name = 'DS protokol';

    // Normalize dates for IndexedDB / UI
    const now = Date.now();
    if(!p.createdAt || (typeof p.createdAt === 'string')) p.createdAt = now;
    p.updatedAt = now;
    if(!Number.isFinite(p.loopCount)) p.loopCount = 1;

    // Avoid id clash
    try{
      await a.loadProtocolsFromDB?.();
      if(Array.isArray(a.protocols) && a.protocols.some(x=>x.id===p.id)){
        p.id = a._newProtoId?.() || (`DS_${Date.now()}`);
      }
    }catch(_){}

    // Persist
    if(a.db?.putProtocol){
      await a.db.putProtocol(p);
    }else{
      a.protocols = Array.isArray(a.protocols) ? a.protocols : [];
      a.protocols.unshift(p);
    }

    // Cleanup bridge
    localStorage.removeItem('SINET_DS_BRIDGE');

    // Reload + show
    try{ await a.loadProtocolsFromDB?.(); }catch(_){}
    try{ a.nav?.('protocols'); }catch(_){}
    try{ a.renderProtocolsUI?.(); }catch(_){}

    a.showToast?.(`✅ DS Generator: protokol dodat u "Moji protokoli" (${p.name}).`, {timeoutMs: 10000});
    return true;
  }catch(e){
    console.warn('__importDsBridgeIfAny failed', e);
    return false;
  }
}
window.addEventListener('DOMContentLoaded', async () => {
  await app.init();
  try { await __importDsBridgeIfAny(); } catch(e) { console.warn('DS import call failed', e); }
});
window.app = app;
window.nav = (id) => app.nav(id);

window.playFromModal = () => app.playFromModal();
window.toggleFavoriteFromModal = () => app.toggleFavoriteFromModal();
window.addToPlaylistFromModal = () => app.addToPlaylistFromModal();
window.closeModal = () => app.closeModal();
window.openAcupressureViewer = (itemId, idx) => app.openAcupressureViewer(itemId, idx);
window.closeAcupressureViewer = () => app.closeAcupressureViewer();


// === SINET v14.7 – GLOBAL UI HOOKS (for inline onclick in index.html) ===
(function(){
  const getApp = () => window.app || window.__app || null;

  window.startProtocol = function(){
    const a = getApp();
    if (a && typeof a.startProtocol === 'function') return a.startProtocol();
    console.warn("startProtocol(): app not ready");
  };

  window.togglePause = function(){
    const a = getApp();
    if (a && typeof a.togglePlayPause === 'function') return a.togglePlayPause();
    console.warn("togglePause(): app not ready");
  };

  window.stopAudio = function(){
    const a = getApp();
    if (a && typeof a.stopPlayer === 'function') return a.stopPlayer(true);
    // fallback: try audio engine directly
    if (a && a.audio && typeof a.audio.stop === 'function') return a.audio.stop();
    console.warn("stopAudio(): app not ready");
  };

  window.resetAppCache = async function(){
    try {
      if ('serviceWorker' in navigator) {
        const regs = await navigator.serviceWorker.getRegistrations();
        for (const r of regs) await r.unregister();
      }
      if (window.caches && typeof caches.keys === 'function') {
        const keys = await caches.keys();
        for (const k of keys) await caches.delete(k);
      }
    } catch (e) {
      console.warn("resetAppCache failed", e);
    }
    // Hard reload
    try { location.reload(); } catch(_) {}
  };
})();



// Global helpers for inline HTML onclick
window.toggleNowList = () => window.app && window.app.toggleNowList();
window.toggleDockLoopPanel = () => window.app && window.app.toggleDockLoopPanel();
window.onDockRepeatChange = () => window.app && window.app.onDockRepeatChange();
window.clearPlaylist = () => window.app && window.app.clearPlaylist();
window.doSearch = (v) => window.app && window.app.filterCatalog(v);
window.generateAIPrompt = () => window.app && window.app.generateAIPrompt();
window.copyAIPrompt = () => window.app && window.app.copyAIPrompt();
window.exportCatalogTxt = (mode) => window.app && window.app.exportCatalogTxt(mode);
window.exportCatalogSTL = (mode) => window.app && window.app.exportCatalogSTL(mode);


// Protocols (global onclick helpers)
window.newProtocol = () => window.app && window.app.openProtocolEditor(null);
window.createProtocolFromFavorites = () => window.app && window.app.createProtocolFromFavorites();
window.createProtocolFromQueue = () => window.app && window.app.createProtocolFromQueue();
window.exportProtocols = () => window.app && window.app.exportProtocols();
window.importProtocols = () => window.app && window.app.importProtocolsPrompt();
