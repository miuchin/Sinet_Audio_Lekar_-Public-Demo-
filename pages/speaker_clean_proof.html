<!doctype html>
<html lang="sr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>iPhone Speaker Clean + Test + Proof (Mobile Friendly)</title>
    <link rel="stylesheet" href="../css/sinet-quickbar.css?v=15.7.7.7">
    <script defer src="../js/sinet-quickbar.js?v=15.7.7.7"></script>

  <style>
    body { font-family: -apple-system, system-ui, Arial, sans-serif; margin: 18px; line-height: 1.35; }
    h1 { font-size: 18px; margin: 0 0 10px; }
    h2 { margin:0 0 8px; font-size:16px; }
    .card { border: 1px solid #ddd; border-radius: 12px; padding: 14px; margin: 12px 0; }
    button { padding: 12px 14px; border-radius: 10px; border: 1px solid #aaa; background: #f6f6f6; font-size: 16px; }
    button:active { transform: scale(0.99); }
    .row { display: flex; gap: 10px; flex-wrap: wrap; align-items: center; }
    .row > * { flex: 1 1 auto; }
    input[type="range"], input[type="number"], select { width: 100%; }
    .small { font-size: 13px; color: #333; }
    .warn { color: #8a0000; font-weight: 900; }
    .ok { color: #0a6b2b; font-weight: 900; }
    .mono { font-family: ui-monospace, Menlo, monospace; }
    .grid { display:grid; grid-template-columns: 1fr 1fr; gap:10px; }
    @media (max-width: 520px){ .grid{ grid-template-columns: 1fr; } }
    .pill { display:inline-block; padding:4px 10px; border:1px solid #ddd; border-radius:999px; background:#fafafa; }
    .hint { background:#fafafa; border:1px dashed #ddd; padding:10px; border-radius:12px; }
    .divider { height:1px; background:#eee; margin:12px 0; }
    pre { background:#fafafa; border:1px solid #eee; padding:10px; border-radius:12px; overflow:auto; }
  </style>
</head>
<body>
<div class="card" style="position:sticky;top:0;z-index:999;background:#fff;">
  <div class="row" style="justify-content:space-between;align-items:center;">
    <button id="bBack" style="border-color:#4A90E2;">‚Üê Nazad u SINET</button>
    <span class="small" style="text-align:right;">Alat: Speaker Clean ‚Ä¢ miuchins &amp; SINET AI</span>
  </div>
</div>
<script>
  (function(){
    function goBack(){
      try{
        var p = new URLSearchParams(location.search);
        var back = p.get('back');
        if(back){ location.href = back; return; }
      }catch(e){}
      location.href = '../index.html';
    }
    var b = document.getElementById('bBack');
    if(b) b.addEventListener('click', goBack);
  })();
</script>
  <h1>üîä Speaker Clean + Test + Proof (Mobile)</h1>

  <div class="card">
    <div class="warn">‚ö†Ô∏è Bezbedno: Telefon volume 70‚Äì80% max, Master 0.60‚Äì0.75. Ako krƒçi ‚Üí STOP.</div>
    <div class="small">
      <b>AUTO RUN</b> radi: (1) poku≈°a PROOF (mikrofon) ako mo≈æe ‚Üí (2) CLEAN desnog ‚Üí (3) TEST ‚Üí (4) REPORT.  
      Ako mic nije dostupan (ƒçesto na file:// i nekim preview-ima), radi <b>fallback</b>: CLEAN + TEST + obja≈°njenje u report-u.
    </div>
  </div>

  <div class="card">
    <div class="grid">
      <div>
        <div><b>Master jaƒçina</b>: <span id="volLabel">0.70</span></div>
        <input id="vol" type="range" min="0" max="1" step="0.01" value="0.70" />
        <div class="small">U aplikaciji ~0.70. Telefon volume ~75%.</div>
      </div>

      <div>
        <label class="pill"><input id="safeMode" type="checkbox" checked /> Ultra-safe limiter</label>
        <div class="small">
          <b>Cap boost:</b>
          <select id="capDb">
            <option value="6" selected>+6 dB (preporuka)</option>
            <option value="8">+8 dB</option>
          </select>
        </div>
      </div>
    </div>

    <div style="margin-top:10px">
      <div><b>Status:</b> <span id="status">spremno</span></div>
      <div class="small">Segment: <span id="segment">‚Äî</span> ‚Ä¢ Preostalo: <span id="remain">‚Äî</span></div>
      <div class="small">Kompenzacija: R gain <span id="gainR" class="mono">1.00</span> (R dB <span id="dbR" class="mono">0.0</span>)</div>
    </div>
  </div>

  <div class="card">
    <h2>‚ñ∂Ô∏è Jedan klik</h2>
    <div class="row">
      <button id="bAuto">AUTO RUN (Proof‚ÜíClean‚ÜíTest)</button>
      <button id="bStop" style="border-color:#8a0000;">STOP</button>
    </div>
    <div class="hint small" style="margin-top:10px">
      <b>Quick checklist:</b>
      <ul style="margin:8px 0 0 18px;">
        <li>Skini maskicu.</li>
        <li>Oƒçisti re≈°etku suvom ƒçetkicom 30‚Äì40s.</li>
        <li>Telefon na sto, portrait, ti≈°ina.</li>
      </ul>
    </div>
  </div>

  <div class="card">
    <h2>üßº Ruƒçno (Clean)</h2>
    <div class="row">
      <button id="bClean">Clean desnog (Puls‚Üí165‚ÜíSweep)</button>
      <button id="bPulse">Puls 120 (R)</button>
      <button id="b165">165 Hz (R) 60s</button>
    </div>
    <div class="row" style="margin-top:10px">
      <button id="bSweep">Sweep 50‚Üí300 (R) 60s</button>
      <button id="bRattle">Rattle 80‚Üí260 (20s)</button>
      <button id="bStereo">Stereo test (L‚ÜíR‚Üíoba)</button>
    </div>
  </div>

  <div class="card">
    <h2>üìÑ Report</h2>
    <div class="row">
      <button id="bCopyReport">Copy report</button>
      <span id="copyMsg" class="ok"></span>
    </div>
    <pre id="report" class="mono">Nema report-a jo≈°.</pre>
  </div>

  <div class="card">
    <h2>ü™µ Log / Gre≈°ke</h2>
    <pre id="log" class="mono">Log prazan.</pre>
    <div class="small">Ako ne≈°to ne radi u ‚ÄúKoder‚Äù preview, ovde ƒáe pisati razlog (mic blokiran, audio suspended, itd.).</div>
  </div>

<script>
(() => {
  // ================= LOGGING =================
  const elLog = document.getElementById('log');
  function log(msg){
    const t = new Date().toLocaleTimeString();
    elLog.textContent = `[${t}] ${msg}\n` + (elLog.textContent || '');
  }
  window.addEventListener('error', (e) => log(`JS ERROR: ${e.message}`));
  window.addEventListener('unhandledrejection', (e) => log(`PROMISE ERROR: ${e.reason?.message || e.reason}`));

  function originInfo(){
    try { return `${location.protocol}//${location.host}`; } catch { return 'unknown'; }
  }
  log(`Origin: ${originInfo()}`);
  if (location.protocol === 'file:') log('NAPOMENA: file:// na iOS ƒçesto blokira mikrofon. Proof mo≈æe pasti, ali Clean/Test rade.');
  if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) log('NAPOMENA: getUserMedia nije dostupno u ovom okru≈æenju (preview/sandbox).');

  // ================= UI =================
  const elStatus = document.getElementById('status');
  const elSegment = document.getElementById('segment');
  const elRemain = document.getElementById('remain');
  const elVol = document.getElementById('vol');
  const elVolLabel = document.getElementById('volLabel');
  const elSafe = document.getElementById('safeMode');
  const elCapDb = document.getElementById('capDb');
  const elGainR = document.getElementById('gainR');
  const elDbR = document.getElementById('dbR');
  const elReport = document.getElementById('report');
  const elCopyMsg = document.getElementById('copyMsg');

  function setStatus(s){ elStatus.textContent = s; }
  function setSegment(s){ elSegment.textContent = s; }
  function setRemain(s){ elRemain.textContent = s; }

  // ================= TIMERS =================
  let stopFlag = false;
  let timers = [];
  let remainTimer = null;

  function clearTimers(){
    timers.forEach(t => clearTimeout(t));
    timers = [];
    if (remainTimer){ clearInterval(remainTimer); remainTimer = null; }
  }

  function sleep(ms){
    return new Promise(res => {
      const t = setTimeout(res, ms);
      timers.push(t);
    });
  }

  function msToMMSS(ms){
    const s = Math.ceil(ms/1000);
    const m = Math.floor(s/60);
    const r = s % 60;
    return `${m}:${String(r).padStart(2,'0')}`;
  }

  function startRemainCountdown(totalMs){
    const t0 = Date.now();
    setRemain(msToMMSS(totalMs));
    remainTimer = setInterval(() => {
      const left = Math.max(0, totalMs - (Date.now() - t0));
      setRemain(msToMMSS(left));
      if (left <= 0){
        clearInterval(remainTimer);
        remainTimer = null;
        setRemain('0:00');
      }
    }, 250);
  }

  // ================= AUDIO GRAPH =================
  let ctx=null, master=null, limiter=null, panner=null, splitter=null, gainL=null, gainR=null, merger=null;
  let osc=null, oscGain=null, noiseSrc=null;

  // mic
  let micStream=null, micSource=null, analyser=null;

  // compensation (keep L=1, adjust R)
  let compGainR = 1.0;

  function dbToGain(db){ return Math.pow(10, db/20); }
  function gainToDb(g){ return 20*Math.log10(Math.max(1e-6, g)); }
  function clamp(x,a,b){ return Math.max(a, Math.min(b, x)); }

  function ensureAudio(){
    if (!ctx){
      ctx = new (window.AudioContext || window.webkitAudioContext)();

      // source -> panner -> splitter -> gainL/gainR -> merger -> master -> limiter? -> destination
      panner = ctx.createStereoPanner();
      panner.pan.value = 0;

      splitter = ctx.createChannelSplitter(2);
      gainL = ctx.createGain();
      gainR = ctx.createGain();
      merger = ctx.createChannelMerger(2);

      master = ctx.createGain();
      master.gain.value = parseFloat(elVol.value);

      limiter = ctx.createDynamicsCompressor();
      limiter.threshold.value = -18;
      limiter.knee.value = 20;
      limiter.ratio.value = 6;
      limiter.attack.value = 0.005;
      limiter.release.value = 0.12;

      panner.connect(splitter);
      splitter.connect(gainL, 0);
      splitter.connect(gainR, 1);
      gainL.connect(merger, 0, 0);
      gainR.connect(merger, 0, 1);
      merger.connect(master);

      applyComp();
      wireOutput();

      log(`AudioContext created. state=${ctx.state}`);
    }

    if (ctx.state !== 'running'){
      ctx.resume().then(() => log(`AudioContext resumed. state=${ctx.state}`))
                 .catch(e => log(`AudioContext resume FAILED: ${e.message || e}`));
    }
  }

  function wireOutput(){
    try { master.disconnect(); } catch {}
    try { limiter.disconnect(); } catch {}

    if (elSafe.checked){
      master.connect(limiter);
      limiter.connect(ctx.destination);
    } else {
      master.connect(ctx.destination);
    }
  }

  function applyComp(){
    if (!gainR) return;
    gainL.gain.value = 1.0;
    gainR.gain.value = compGainR;

    elGainR.textContent = compGainR.toFixed(2);
    elDbR.textContent = gainToDb(compGainR).toFixed(1);
  }

  function computeCompFrom(rmsL, rmsR){
    const eps = 1e-6;
    const ratioLR = (rmsL + eps) / (rmsR + eps); // if R weaker -> >1
    const cap = parseFloat(elCapDb.value || '6');
    const maxGain = dbToGain(cap);
    compGainR = clamp(ratioLR, 0.4, maxGain);
    applyComp();
    return compGainR;
  }

  function envelopeParams(){
    return elSafe.checked ? {attack:0.05, release:0.10} : {attack:0.03, release:0.08};
  }

  function stopNow(){
    stopFlag = true;
    clearTimers();

    try { if (oscGain && ctx) oscGain.gain.setValueAtTime(0, ctx.currentTime); } catch {}
    try { if (osc) osc.stop(); } catch {}
    osc = null; oscGain = null;

    try { if (noiseSrc) noiseSrc.stop(); } catch {}
    noiseSrc = null;

    // stop mic if running
    try { if (micSource) micSource.disconnect(); } catch {}
    micSource = null;
    analyser = null;
    if (micStream){
      micStream.getTracks().forEach(t => t.stop());
      micStream = null;
    }

    setStatus('stop');
    setSegment('‚Äî');
    setRemain('‚Äî');
    log('STOP pressed.');
  }

  function applyAttack(g, t0, sustain=1.0){
    const {attack} = envelopeParams();
    g.gain.cancelScheduledValues(t0);
    g.gain.setValueAtTime(0, t0);
    g.gain.linearRampToValueAtTime(sustain, t0 + attack);
  }

  function fadeOutAndStop(){
    if (!ctx || !osc || !oscGain) return;
    const {release} = envelopeParams();
    const t = ctx.currentTime;
    try{
      oscGain.gain.cancelScheduledValues(t);
      oscGain.gain.setValueAtTime(oscGain.gain.value, t);
      oscGain.gain.linearRampToValueAtTime(0, t + release);
      osc.stop(t + release + 0.02);
    } catch {}
    osc = null; oscGain = null;
  }

  async function playSine(freq, sec, label, pan){
    stopFlag = false;
    ensureAudio();

    setStatus('svira');
    setSegment(label);
    startRemainCountdown(sec*1000);

    panner.pan.value = (pan==='left') ? -1 : (pan==='right') ? 1 : 0;

    osc = ctx.createOscillator();
    osc.type = 'sine';
    osc.frequency.setValueAtTime(freq, ctx.currentTime);

    oscGain = ctx.createGain();
    oscGain.gain.value = 0;

    osc.connect(oscGain);
    oscGain.connect(panner);

    const t0 = ctx.currentTime;
    applyAttack(oscGain, t0, 1.0);
    osc.start(t0);

    await sleep(sec*1000);
    if (stopFlag) return;

    fadeOutAndStop();
    setStatus('spremno'); setSegment('‚Äî'); setRemain('‚Äî');
  }

  async function playSweep(f0, f1, sec, label, pan){
    stopFlag = false;
    ensureAudio();

    setStatus('svira');
    setSegment(label);
    startRemainCountdown(sec*1000);

    panner.pan.value = (pan==='left') ? -1 : (pan==='right') ? 1 : 0;

    osc = ctx.createOscillator();
    osc.type = 'sine';

    oscGain = ctx.createGain();
    oscGain.gain.value = 0;

    osc.connect(oscGain);
    oscGain.connect(panner);

    const t0 = ctx.currentTime;
    osc.frequency.setValueAtTime(f0, t0);
    osc.frequency.linearRampToValueAtTime(f1, t0 + sec);
    applyAttack(oscGain, t0, 1.0);

    osc.start(t0);

    await sleep(sec*1000);
    if (stopFlag) return;

    fadeOutAndStop();
    setStatus('spremno'); setSegment('‚Äî'); setRemain('‚Äî');
  }

  async function playNoise(sec, label, pan){
    stopFlag = false;
    ensureAudio();

    setStatus('svira');
    setSegment(label);
    startRemainCountdown(sec*1000);

    panner.pan.value = (pan==='left') ? -1 : (pan==='right') ? 1 : 0;

    const N = Math.floor(ctx.sampleRate * sec);
    const buf = ctx.createBuffer(1, N, ctx.sampleRate);
    const d = buf.getChannelData(0);
    for (let i=0; i<N; i++) d[i] = (Math.random()*2-1) * 0.22;

    const src = ctx.createBufferSource();
    src.buffer = buf;

    const hp = ctx.createBiquadFilter(); hp.type='highpass'; hp.frequency.value=80;
    const lp = ctx.createBiquadFilter(); lp.type='lowpass'; lp.frequency.value=5000;

    const g = ctx.createGain(); g.gain.value = 0;

    src.connect(hp); hp.connect(lp); lp.connect(g); g.connect(panner);
    applyAttack(g, ctx.currentTime, 0.9);

    src.start();
    noiseSrc = src;

    await sleep(sec*1000);
    if (stopFlag) return;

    const {release} = envelopeParams();
    try{
      g.gain.setValueAtTime(g.gain.value, ctx.currentTime);
      g.gain.linearRampToValueAtTime(0, ctx.currentTime + release);
      src.stop(ctx.currentTime + release + 0.02);
    } catch {}
    noiseSrc = null;

    setStatus('spremno'); setSegment('‚Äî'); setRemain('‚Äî');
  }

  async function playPulse(freq=120, onSec=10, offSec=2, cycles=3, label, pan){
    stopFlag = false;
    ensureAudio();

    setStatus('svira');
    setSegment(label);
    startRemainCountdown((onSec+offSec)*cycles*1000);

    panner.pan.value = (pan==='left') ? -1 : (pan==='right') ? 1 : 0;

    osc = ctx.createOscillator();
    osc.type = 'sine';
    osc.frequency.setValueAtTime(freq, ctx.currentTime);

    oscGain = ctx.createGain();
    oscGain.gain.value = 0;

    osc.connect(oscGain);
    oscGain.connect(panner);
    osc.start(ctx.currentTime);

    for (let i=0; i<cycles; i++){
      if (stopFlag) return;
      applyAttack(oscGain, ctx.currentTime, 1.0);
      await sleep(onSec*1000);
      if (stopFlag) return;

      const {release} = envelopeParams();
      const t = ctx.currentTime;
      try{
        oscGain.gain.cancelScheduledValues(t);
        oscGain.gain.setValueAtTime(oscGain.gain.value, t);
        oscGain.gain.linearRampToValueAtTime(0, t + release);
      } catch {}
      await sleep(offSec*1000);
    }

    if (stopFlag) return;
    fadeOutAndStop();
    setStatus('spremno'); setSegment('‚Äî'); setRemain('‚Äî');
  }

  // ================= MIC (OPTIONAL PROOF) =================
  async function startMic(){
    ensureAudio();
    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia){
      throw new Error('getUserMedia not available');
    }
    if (micStream) return;

    micStream = await navigator.mediaDevices.getUserMedia({ audio: true });
    micSource = ctx.createMediaStreamSource(micStream);
    analyser = ctx.createAnalyser();
    analyser.fftSize = 2048;
    micSource.connect(analyser);
  }

  function measureRMS(sampleMs=900){
    return new Promise((resolve) => {
      if (!analyser){ resolve(0); return; }
      const buf = new Float32Array(analyser.fftSize);
      const t0 = Date.now();
      let sum = 0, n = 0;

      const tick = () => {
        analyser.getFloatTimeDomainData(buf);
        let s = 0;
        for (let i=0; i<buf.length; i++){
          const v = buf[i];
          s += v*v;
        }
        const rms = Math.sqrt(s / buf.length);
        sum += rms;
        n++;

        if (Date.now() - t0 >= sampleMs) resolve(sum / Math.max(1,n));
        else requestAnimationFrame(tick);
      };
      tick();
    });
  }

  function ratioToDb(r){ return 20*Math.log10(Math.max(1e-6, r)); }

  async function calibrateOnce(tag){
    // play L noise then R noise, measure RMS after each
    setStatus('proof');
    setSegment(`PROOF ${tag}: LEVO (2.5s)`);
    await playNoise(2.5, `PROOF ${tag} L`, 'left');
    if (stopFlag) return null;
    const rmsL = await measureRMS(900);

    setSegment(`PROOF ${tag}: DESNO (2.5s)`);
    await playNoise(2.5, `PROOF ${tag} R`, 'right');
    if (stopFlag) return null;
    const rmsR = await measureRMS(900);

    return { rmsL, rmsR };
  }

  async function proofPrePost(){
    // returns report object or null if not possible
    try{
      await startMic();
      log('Mic OK: starting PRE/POST proof.');
    } catch (e){
      log(`Mic not available: ${e.message || e}. Using fallback (no proof).`);
      return null;
    }

    // PRE
    setSegment('PROOF PRE (L/R)');
    const pre = await calibrateOnce('PRE');
    if (!pre || stopFlag) return null;

    const preDefDb = ratioToDb((pre.rmsL+1e-6)/(pre.rmsR+1e-6));
    computeCompFrom(pre.rmsL, pre.rmsR);

    return { pre, preDefDb };
  }

  // ================= PIPELINES =================
  async function runCleanRight(){
    setStatus('clean');
    setSegment('Clean: Puls 120 (DESNO)');
    await playPulse(120,10,2,3,'Puls 120 (R)', 'right');
    if (stopFlag) return;

    setSegment('Pauza 2s'); startRemainCountdown(2000); await sleep(2000);
    if (stopFlag) return;

    setSegment('Clean: 165 Hz (DESNO, 60s)');
    await playSine(165,60,'165 Hz (R) 60s', 'right');
    if (stopFlag) return;

    setSegment('Pauza 2s'); startRemainCountdown(2000); await sleep(2000);
    if (stopFlag) return;

    setSegment('Clean: Sweep 50‚Üí300 (DESNO, 60s)');
    await playSweep(50,300,60,'Sweep 50‚Üí300 (R) 60s', 'right');
  }

  async function runTest(){
    setStatus('test');
    setSegment('Stereo test: L 2s ‚Üí R 2s ‚Üí oba 2s');
    startRemainCountdown(6000);

    await playSine(440,2,'TEST L (440 Hz)', 'left');
    if (stopFlag) return;
    await playSine(440,2,'TEST R (440 Hz)', 'right');
    if (stopFlag) return;
    await playSine(440,2,'TEST oba (440 Hz)', 'stereo');

    if (stopFlag) return;
    setSegment('Rattle 80‚Üí260 (20s) ‚Äî slu≈°aj zveckanje');
    await playSweep(80,260,20,'Rattle 80‚Üí260 (20s)', 'stereo');

    setStatus('spremno');
    setSegment('Test zavr≈°en.');
    setRemain('‚Äî');
  }

  async function autoRun(){
    stopFlag = false;
    ensureAudio();
    elReport.textContent = 'AUTO RUN u toku‚Ä¶';
    log('AUTO RUN started.');

    // Attempt proof PRE
    let proof = await proofPrePost();
    if (stopFlag) return;

    // Clean
    await runCleanRight();
    if (stopFlag) return;

    // Attempt POST proof if mic available
    let post = null;
    let postDefDb = null;
    if (proof && analyser){
      setSegment('PROOF POST (L/R)');
      post = await calibrateOnce('POST');
      if (!post || stopFlag) return;

      postDefDb = ratioToDb((post.rmsL+1e-6)/(post.rmsR+1e-6));
      // Update comp to POST
      computeCompFrom(post.rmsL, post.rmsR);
    }

    // Test
    await runTest();
    if (stopFlag) return;

    // Build report
    const cap = elCapDb.value;
    const limiterOn = elSafe.checked ? 'ON' : 'OFF';
    const masterVal = parseFloat(elVol.value).toFixed(2);

    if (!proof){
      elReport.textContent =
`=== REPORT (fallback, bez mikrofona) ===
Master: ${masterVal} | Limiter: ${limiterOn} | Cap: +${cap} dB

Mic/Proof nije dostupan u ovom okru≈æenju (ƒçesto file:// ili editor preview).
Odraƒëeno: CLEAN desnog + TEST (Stereo + Rattle).

Predlog:
  - Uradi mehaniƒçko ƒçi≈°ƒáenje re≈°etke (ƒçetkica + Blu-Tack tap) pa ponovi AUTO RUN.
  - Ako je desni i dalje duplo slab: verovatno zapu≈°enje duboko ili hardver.
`;
    } else if (proof && post){
      const improvement = proof.preDefDb - postDefDb;
      const verdict =
        (improvement >= 3.0) ? '‚úÖ Verovatno zapu≈°enje/vlaga (realno pobolj≈°anje).' :
        (Math.abs(improvement) <= 1.0) ? '‚ùå Skoro bez promene: verovatniji hardver/dubinsko zapu≈°enje.' :
        '‚ö†Ô∏è Delimiƒçna promena: moguƒáe i zapu≈°enje i hardver (ili varijacija buke/polo≈æaja).';

      elReport.textContent =
`=== PROOF REPORT (PRE/POST) ===
Master: ${masterVal} | Limiter: ${limiterOn} | Cap: +${cap} dB

PRE:
  RMS_L=${proof.pre.rmsL.toFixed(6)}
  RMS_R=${proof.pre.rmsR.toFixed(6)}
  R deficit (L/R)=${proof.preDefDb.toFixed(1)} dB

POST:
  RMS_L=${post.rmsL.toFixed(6)}
  RMS_R=${post.rmsR.toFixed(6)}
  R deficit (L/R)=${postDefDb.toFixed(1)} dB

Improvement (PRE-POST)=${improvement.toFixed(1)} dB
Verdikt: ${verdict}

Sledeƒái potez:
  - improvement ‚â• 3 dB: ponovi cleaning jo≈° 1 rundu posle 2 min cooldown.
  - improvement ‚â§ 1 dB i deficit velik: mehaniƒçko ƒçi≈°ƒáenje + servis ako ne proƒëe.
`;
    } else {
      elReport.textContent =
`=== REPORT (delimiƒçan) ===
Master: ${masterVal} | Limiter: ${limiterOn} | Cap: +${cap} dB

PRE je odraƒëen, ali POST nije (mic prekinut/blocked).
Odraƒëeno: CLEAN + TEST.
Poku≈°aj ponovo na https/localhost za kompletan PROOF.
`;
    }

    setStatus('spremno');
    setSegment('AUTO RUN zavr≈°en.');
    setRemain('‚Äî');
    log('AUTO RUN completed.');
  }

  // ================= EVENTS =================
  elVol.addEventListener('input', () => {
    const v = parseFloat(elVol.value);
    elVolLabel.textContent = v.toFixed(2);
    if (master) master.gain.value = v;
  });

  elSafe.addEventListener('change', () => { if (ctx) wireOutput(); });
  elCapDb.addEventListener('change', () => { applyComp(); });

  document.getElementById('bStop').addEventListener('click', () => stopNow());
  document.getElementById('bAuto').addEventListener('click', () => autoRun());

  document.getElementById('bClean').addEventListener('click', () => runCleanRight());
  document.getElementById('bPulse').addEventListener('click', () => playPulse(120,10,2,3,'Puls 120 (R)', 'right'));
  document.getElementById('b165').addEventListener('click', () => playSine(165,60,'165 Hz (R) 60s', 'right'));
  document.getElementById('bSweep').addEventListener('click', () => playSweep(50,300,60,'Sweep 50‚Üí300 (R) 60s', 'right'));

  document.getElementById('bRattle').addEventListener('click', () => playSweep(80,260,20,'Rattle 80‚Üí260 (20s)', 'stereo'));
  document.getElementById('bStereo').addEventListener('click', () => runTest());

  document.getElementById('bCopyReport').addEventListener('click', async () => {
    try{
      await navigator.clipboard.writeText(elReport.textContent);
      elCopyMsg.textContent = '‚úÖ Kopirano!';
      setTimeout(() => elCopyMsg.textContent='', 1500);
    } catch {
      elCopyMsg.textContent = '‚ùå Clipboard blokiran. Ruƒçno oznaƒçi report i kopiraj.';
      setTimeout(() => elCopyMsg.textContent='', 2500);
    }
  });

  // ================= INIT =================
  elVolLabel.textContent = parseFloat(elVol.value).toFixed(2);
  setStatus('spremno');
  applyComp();
  log('Ready. Tip: otvori u Safari (ne u editor preview) za najbolji rezultat.');
})();
</script>
</body>
</html>
